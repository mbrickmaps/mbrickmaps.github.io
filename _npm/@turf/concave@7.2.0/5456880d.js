/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.37.0.
 * Original file: /npm/@turf/concave@7.2.0/dist/esm/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{distance as e}from"../distance@7.2.0/379bfd17.js";import{feature as t,featureCollection as o,isObject as r,multiLineString as n,lineString as s,geometryCollection as i}from"../helpers@7.2.0/28807c9c.js";import{featureEach as c,flattenEach as u,lineReduce as m}from"../meta@7.2.0/c0f2fe64.js";import{tin as l}from"../tin@7.2.0/5b8d49a4.js";import{clone as a}from"../clone@7.2.0/5b9e5666.js";import{getType as f}from"../invariant@7.2.0/671cab78.js";import{merge as g}from"../../topojson-client@3.1.0/44d97fcb.js";import{topology as p}from"../../topojson-server@3.0.1/470bdfd4.js";function h(e,t={}){if(!r(t=t||{}))throw new Error("options is invalid");const o=t.mutate;if("FeatureCollection"!==f(e))throw new Error("geojson must be a FeatureCollection");if(!e.features.length)throw new Error("geojson is empty");!1!==o&&void 0!==o||(e=a(e));const i=[],c=m(e,((e,t)=>{const o=function(e,t){const o=e.geometry.coordinates,r=t.geometry.coordinates,n=w(o[0]),i=w(o[o.length-1]),c=w(r[0]),u=w(r[r.length-1]);let m;if(n===u)m=r.concat(o.slice(1));else if(c===i)m=o.concat(r.slice(1));else if(n===c)m=o.slice(1).reverse().concat(r);else{if(i!==u)return null;m=o.concat(r.reverse().slice(1))}return s(m)}(e,t);return o||(i.push(e),t)}));return c&&i.push(c),i.length?1===i.length?i[0]:n(i.map((e=>e.coordinates))):null}function w(e){return e[0].toString()+","+e[1].toString()}function d(e,t={}){if(!r(t=t||{}))throw new Error("options is invalid");const o=t.mutate;if("FeatureCollection"!==f(e))throw new Error("geojson must be a FeatureCollection");if(!e.features.length)throw new Error("geojson is empty");!1!==o&&void 0!==o||(e=a(e));const n=function(e){const t={};u(e,(e=>{t[e.geometry.type]=!0}));const o=Object.keys(t);if(1===o.length)return o[0];return null}(e);if(!n)throw new Error("geojson must be homogenous");const s=e;switch(n){case"LineString":return h(s,t);case"Polygon":return function(e,t={}){if("FeatureCollection"!==f(e))throw new Error("geojson must be a FeatureCollection");if(!e.features.length)throw new Error("geojson is empty");!1!==t.mutate&&void 0!==t.mutate||(e=a(e));const o=[];u(e,(e=>{o.push(e.geometry)}));const r=p({geoms:i(o).geometry});return g(r,r.objects.geoms.geometries)}(s,t);default:throw new Error(n+" is not supported")}}function y(r,n={}){const s=n.maxEdge||1/0,i=function(e){const t=[],r={};return c(e,(e=>{if(!e.geometry)return;const o=e.geometry.coordinates.join("-");Object.prototype.hasOwnProperty.call(r,o)||(t.push(e),r[o]=!0)})),o(t)}(r),u=l(i);if(u.features=u.features.filter((t=>{const o=t.geometry.coordinates[0][0],r=t.geometry.coordinates[0][1],i=t.geometry.coordinates[0][2],c=e(o,r,n),u=e(r,i,n),m=e(o,i,n);return c<=s&&u<=s&&m<=s})),u.features.length<1)return null;const m=d(u);return 1===m.coordinates.length&&(m.coordinates=m.coordinates[0],m.type="Polygon"),t(m)}var j=y;export{y as concave,j as default};
