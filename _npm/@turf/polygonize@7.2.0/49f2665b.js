/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.37.0.
 * Original file: /npm/@turf/polygonize@7.2.0/dist/esm/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{featureCollection as e,multiPoint as t,polygon as o,point as s,lineString as i}from"../helpers@7.2.0/28807c9c.js";import{booleanPointInPolygon as r}from"../boolean-point-in-polygon@7.2.0/080fdfef.js";import{envelope as n}from"../envelope@7.2.0/54b97de8.js";import{flattenEach as d,coordReduce as h}from"../meta@7.2.0/c0f2fe64.js";import{featureOf as a}from"../invariant@7.2.0/671cab78.js";function g(e,t,o){const s=t[0]-e[0],i=t[1]-e[1],r=o[0]-t[0],n=o[1]-t[1];return((d=s*n-r*i)>0)-(d<0)||+d;var d}function c(e,t){return t.geometry.coordinates[0].every((t=>r(s(t),e)))}var l=class e{static buildId(e){return e.join(",")}constructor(t){this.id=e.buildId(t),this.coordinates=t,this.innerEdges=[],this.outerEdges=[],this.outerEdgesSorted=!1}removeInnerEdge(e){this.innerEdges=this.innerEdges.filter((t=>t.from.id!==e.from.id))}removeOuterEdge(e){this.outerEdges=this.outerEdges.filter((t=>t.to.id!==e.to.id))}addOuterEdge(e){this.outerEdges.push(e),this.outerEdgesSorted=!1}sortOuterEdges(){this.outerEdgesSorted||(this.outerEdges.sort(((e,t)=>{const o=e.to,s=t.to;if(o.coordinates[0]-this.coordinates[0]>=0&&s.coordinates[0]-this.coordinates[0]<0)return 1;if(o.coordinates[0]-this.coordinates[0]<0&&s.coordinates[0]-this.coordinates[0]>=0)return-1;if(o.coordinates[0]-this.coordinates[0]==0&&s.coordinates[0]-this.coordinates[0]==0)return o.coordinates[1]-this.coordinates[1]>=0||s.coordinates[1]-this.coordinates[1]>=0?o.coordinates[1]-s.coordinates[1]:s.coordinates[1]-o.coordinates[1];const i=g(this.coordinates,o.coordinates,s.coordinates);if(i<0)return 1;if(i>0)return-1;return Math.pow(o.coordinates[0]-this.coordinates[0],2)+Math.pow(o.coordinates[1]-this.coordinates[1],2)-(Math.pow(s.coordinates[0]-this.coordinates[0],2)+Math.pow(s.coordinates[1]-this.coordinates[1],2))})),this.outerEdgesSorted=!0)}getOuterEdges(){return this.sortOuterEdges(),this.outerEdges}getOuterEdge(e){return this.sortOuterEdges(),this.outerEdges[e]}addInnerEdge(e){this.innerEdges.push(e)}},u=class e{getSymetric(){return this.symetric||(this.symetric=new e(this.to,this.from),this.symetric.symetric=this),this.symetric}constructor(e,t){this.from=e,this.to=t,this.next=void 0,this.label=void 0,this.symetric=void 0,this.ring=void 0,this.from.addOuterEdge(this),this.to.addInnerEdge(this)}deleteEdge(){this.from.removeOuterEdge(this),this.to.removeInnerEdge(this)}isEqual(e){return this.from.id===e.from.id&&this.to.id===e.to.id}toString(){return`Edge { ${this.from.id} -> ${this.to.id} }`}toLineString(){return i([this.from.coordinates,this.to.coordinates])}compareTo(e){return g(e.from.coordinates,e.to.coordinates,this.to.coordinates)}},m=class{constructor(){this.edges=[],this.polygon=void 0,this.envelope=void 0}push(e){this.edges.push(e),this.polygon=this.envelope=void 0}get(e){return this.edges[e]}get length(){return this.edges.length}forEach(e){this.edges.forEach(e)}map(e){return this.edges.map(e)}some(e){return this.edges.some(e)}isValid(){return!0}isHole(){const e=this.edges.reduce(((e,t,o)=>(t.from.coordinates[1]>this.edges[e].from.coordinates[1]&&(e=o),e)),0),t=(0===e?this.length:e)-1,o=(e+1)%this.length,s=g(this.edges[t].from.coordinates,this.edges[e].from.coordinates,this.edges[o].from.coordinates);return 0===s?this.edges[t].from.coordinates[0]>this.edges[o].from.coordinates[0]:s>0}toMultiPoint(){return t(this.edges.map((e=>e.from.coordinates)))}toPolygon(){if(this.polygon)return this.polygon;const e=this.edges.map((e=>e.from.coordinates));return e.push(this.edges[0].from.coordinates),this.polygon=o([e])}getEnvelope(){return this.envelope?this.envelope:this.envelope=n(this.toPolygon())}static findEdgeRingContaining(e,t){const o=e.getEnvelope();let i,r;return t.forEach((t=>{const n=t.getEnvelope();if(r&&(i=r.getEnvelope()),!function(e,t){const o=e.geometry.coordinates[0].map((e=>e[0])),s=e.geometry.coordinates[0].map((e=>e[1])),i=t.geometry.coordinates[0].map((e=>e[0])),r=t.geometry.coordinates[0].map((e=>e[1]));return Math.max.apply(null,o)===Math.max.apply(null,i)&&Math.max.apply(null,s)===Math.max.apply(null,r)&&Math.min.apply(null,o)===Math.min.apply(null,i)&&Math.min.apply(null,s)===Math.min.apply(null,r)}(n,o)&&c(n,o)){const o=e.map((e=>e.from.coordinates));let d;for(const e of o)t.some((t=>{return o=e,s=t.from.coordinates,o[0]===s[0]&&o[1]===s[1];var o,s}))||(d=e);d&&t.inside(s(d))&&(r&&!c(i,n)||(r=t))}})),r}inside(e){return r(e,this.toPolygon())}};var f=class e{static fromGeoJson(t){!function(e){if(!e)throw new Error("No geojson passed");if("FeatureCollection"!==e.type&&"GeometryCollection"!==e.type&&"MultiLineString"!==e.type&&"LineString"!==e.type&&"Feature"!==e.type)throw new Error(`Invalid input type '${e.type}'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature`)}(t);const o=new e;return d(t,(e=>{a(e,"LineString","Graph::fromGeoJson"),h(e,((e,t)=>{if(e){const s=o.getNode(e),i=o.getNode(t);o.addEdge(s,i)}return t}))})),o}getNode(e){const t=l.buildId(e);let o=this.nodes[t];return o||(o=this.nodes[t]=new l(e)),o}addEdge(e,t){const o=new u(e,t),s=o.getSymetric();this.edges.push(o),this.edges.push(s)}constructor(){this.edges=[],this.nodes={}}deleteDangles(){Object.keys(this.nodes).map((e=>this.nodes[e])).forEach((e=>this._removeIfDangle(e)))}_removeIfDangle(e){if(e.innerEdges.length<=1){const t=e.getOuterEdges().map((e=>e.to));this.removeNode(e),t.forEach((e=>this._removeIfDangle(e)))}}deleteCutEdges(){this._computeNextCWEdges(),this._findLabeledEdgeRings(),this.edges.forEach((e=>{e.label===e.symetric.label&&(this.removeEdge(e.symetric),this.removeEdge(e))}))}_computeNextCWEdges(e){void 0===e?Object.keys(this.nodes).forEach((e=>this._computeNextCWEdges(this.nodes[e]))):e.getOuterEdges().forEach(((t,o)=>{e.getOuterEdge((0===o?e.getOuterEdges().length:o)-1).symetric.next=t}))}_computeNextCCWEdges(e,t){const o=e.getOuterEdges();let s,i;for(let e=o.length-1;e>=0;--e){let r,n,d=o[e],h=d.symetric;d.label===t&&(r=d),h.label===t&&(n=h),r&&n&&(n&&(i=n),r&&(i&&(i.next=r,i=void 0),s||(s=r)))}i&&(i.next=s)}_findLabeledEdgeRings(){const e=[];let t=0;return this.edges.forEach((o=>{if(o.label>=0)return;e.push(o);let s=o;do{s.label=t,s=s.next}while(!o.isEqual(s));t++})),e}getEdgeRings(){this._computeNextCWEdges(),this.edges.forEach((e=>{e.label=void 0})),this._findLabeledEdgeRings().forEach((e=>{this._findIntersectionNodes(e).forEach((t=>{this._computeNextCCWEdges(t,e.label)}))}));const e=[];return this.edges.forEach((t=>{t.ring||e.push(this._findEdgeRing(t))})),e}_findIntersectionNodes(e){const t=[];let o=e;do{let s=0;o.from.getOuterEdges().forEach((t=>{t.label===e.label&&++s})),s>1&&t.push(o.from),o=o.next}while(!e.isEqual(o));return t}_findEdgeRing(e){let t=e;const o=new m;do{o.push(t),t.ring=o,t=t.next}while(!e.isEqual(t));return o}removeNode(e){e.getOuterEdges().forEach((e=>this.removeEdge(e))),e.innerEdges.forEach((e=>this.removeEdge(e))),delete this.nodes[e.id]}removeEdge(e){this.edges=this.edges.filter((t=>!t.isEqual(e))),e.deleteEdge()}};function E(t){const o=f.fromGeoJson(t);o.deleteDangles(),o.deleteCutEdges();const s=[],i=[];return o.getEdgeRings().filter((e=>e.isValid())).forEach((e=>{e.isHole()?s.push(e):i.push(e)})),s.forEach((e=>{m.findEdgeRingContaining(e,i)&&i.push(e)})),e(i.map((e=>e.toPolygon())))}var p=E;export{p as default,E as polygonize};
