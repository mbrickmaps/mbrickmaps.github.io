<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="generator" content="Observable Framework v1.11.0">
<title>Portfolio</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="preload" as="style" href="./_import/custom-style.95d164d2.css">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="stylesheet" type="text/css" href="./_import/custom-style.95d164d2.css">
<link rel="modulepreload" href="./_observablehq/client.f5ee32d5.js">
<link rel="modulepreload" href="./_observablehq/runtime.3f7f73d9.js">
<link rel="modulepreload" href="./_observablehq/stdlib.2229c972.js">
<link rel="modulepreload" href="./_npm/query-overpass@1.5.5/69ce1f03.js">
<link rel="modulepreload" href="./_npm/d3@7.9.0/7055d4c5.js">
<link rel="modulepreload" href="./_npm/d3-geo-projection@2.9.0/ef1109a2.js">
<link rel="modulepreload" href="./_npm/d3-geo-polygon@2.0.1/d02baae9.js">
<link rel="modulepreload" href="./_npm/d3-geo-scale-bar@1.2.5/273332d7.js">
<link rel="modulepreload" href="./_npm/d3-array@3.2.4/e95f898e.js">
<link rel="modulepreload" href="./_npm/proj4@2.7.5/034b033c.js">
<link rel="modulepreload" href="./_npm/@turf/turf@7.2.0/430a7ea5.js">
<link rel="modulepreload" href="./_npm/geojson-rewind@0.3.1/7d5b99d1.js">
<link rel="modulepreload" href="./_npm/topojson-client@3.1.0/44d97fcb.js">
<link rel="modulepreload" href="./_npm/topojson-simplify@3.0.3/fd9926cb.js">
<link rel="modulepreload" href="./_npm/topojson-server@3.0.1/470bdfd4.js">
<link rel="modulepreload" href="./_npm/polylabel@1.1.0/03ffa5c3.js">
<link rel="modulepreload" href="./_npm/osmtogeojson@2.2.12/5cbbb167.js">
<link rel="modulepreload" href="./_npm/xhr@2.6.0/fb7c3f1a.js">
<link rel="modulepreload" href="./_npm/concat-stream@2.0.0/dca7608e.js">
<link rel="modulepreload" href="./_npm/d3-axis@3.0.0/d44feff9.js">
<link rel="modulepreload" href="./_npm/d3-brush@3.0.0/5830b12a.js">
<link rel="modulepreload" href="./_npm/d3-chord@3.0.1/84d7b8e9.js">
<link rel="modulepreload" href="./_npm/d3-color@3.1.0/2c0cdfa2.js">
<link rel="modulepreload" href="./_npm/d3-contour@4.0.2/626bedc4.js">
<link rel="modulepreload" href="./_npm/d3-delaunay@6.0.4/00c41b5d.js">
<link rel="modulepreload" href="./_npm/d3-dispatch@3.0.1/b5f7cdc6.js">
<link rel="modulepreload" href="./_npm/d3-drag@3.0.0/b22c5864.js">
<link rel="modulepreload" href="./_npm/d3-dsv@3.0.1/407f7a1f.js">
<link rel="modulepreload" href="./_npm/d3-ease@3.0.1/6f15f633.js">
<link rel="modulepreload" href="./_npm/d3-fetch@3.0.1/ef1ec490.js">
<link rel="modulepreload" href="./_npm/d3-force@3.0.0/5e1ff060.js">
<link rel="modulepreload" href="./_npm/d3-format@3.1.0/5851d7ef.js">
<link rel="modulepreload" href="./_npm/d3-geo@3.1.1/dcd02767.js">
<link rel="modulepreload" href="./_npm/d3-hierarchy@3.1.2/f1db2593.js">
<link rel="modulepreload" href="./_npm/d3-interpolate@3.0.1/034b7bcb.js">
<link rel="modulepreload" href="./_npm/d3-path@3.1.0/4bb53638.js">
<link rel="modulepreload" href="./_npm/d3-polygon@3.0.1/bbafde58.js">
<link rel="modulepreload" href="./_npm/d3-quadtree@3.0.1/aa5b35a8.js">
<link rel="modulepreload" href="./_npm/d3-random@3.0.1/32c7fec2.js">
<link rel="modulepreload" href="./_npm/d3-scale@4.0.2/567840a0.js">
<link rel="modulepreload" href="./_npm/d3-scale-chromatic@3.1.0/cf9b720b.js">
<link rel="modulepreload" href="./_npm/d3-selection@3.0.0/5dcd62f4.js">
<link rel="modulepreload" href="./_npm/d3-shape@3.2.0/f8e03c56.js">
<link rel="modulepreload" href="./_npm/d3-time@3.1.0/5bc129e1.js">
<link rel="modulepreload" href="./_npm/d3-time-format@4.1.0/19c92b44.js">
<link rel="modulepreload" href="./_npm/d3-timer@3.0.1/f31b5398.js">
<link rel="modulepreload" href="./_npm/d3-transition@3.0.1/8debb4ba.js">
<link rel="modulepreload" href="./_npm/d3-zoom@3.0.0/4b0cc581.js">
<link rel="modulepreload" href="./_npm/d3-geo@1.12.1/c41d1790.js">
<link rel="modulepreload" href="./_npm/d3-array@1.2.4/f4e365ea.js">
<link rel="modulepreload" href="./_npm/d3-geo-projection@4.0.0/4d7a0412.js">
<link rel="modulepreload" href="./_npm/internmap@2.0.3/5eed35fd.js">
<link rel="modulepreload" href="./_npm/wkt-parser@1.4.0/150b2a9e.js">
<link rel="modulepreload" href="./_npm/mgrs@1.0.0/a6344d72.js">
<link rel="modulepreload" href="./_npm/@turf/along@7.2.0/340ddb96.js">
<link rel="modulepreload" href="./_npm/@turf/angle@7.2.0/c05203bb.js">
<link rel="modulepreload" href="./_npm/@turf/area@7.2.0/63969d19.js">
<link rel="modulepreload" href="./_npm/@turf/bbox@7.2.0/8d64fe90.js">
<link rel="modulepreload" href="./_npm/@turf/bbox-clip@7.2.0/13688b55.js">
<link rel="modulepreload" href="./_npm/@turf/bbox-polygon@7.2.0/a8f44922.js">
<link rel="modulepreload" href="./_npm/@turf/bearing@7.2.0/1c0dd5b9.js">
<link rel="modulepreload" href="./_npm/@turf/bezier-spline@7.2.0/cafbabd4.js">
<link rel="modulepreload" href="./_npm/@turf/boolean-clockwise@7.2.0/a664d97e.js">
<link rel="modulepreload" href="./_npm/@turf/boolean-concave@7.2.0/4dd037a5.js">
<link rel="modulepreload" href="./_npm/@turf/boolean-contains@7.2.0/a3a2c1bd.js">
<link rel="modulepreload" href="./_npm/@turf/boolean-crosses@7.2.0/54a80438.js">
<link rel="modulepreload" href="./_npm/@turf/boolean-disjoint@7.2.0/8c36564f.js">
<link rel="modulepreload" href="./_npm/@turf/boolean-equal@7.2.0/5d6dd729.js">
<link rel="modulepreload" href="./_npm/@turf/boolean-intersects@7.2.0/6311cec8.js">
<link rel="modulepreload" href="./_npm/@turf/boolean-overlap@7.2.0/280e7942.js">
<link rel="modulepreload" href="./_npm/@turf/boolean-parallel@7.2.0/25135390.js">
<link rel="modulepreload" href="./_npm/@turf/boolean-point-in-polygon@7.2.0/080fdfef.js">
<link rel="modulepreload" href="./_npm/@turf/boolean-point-on-line@7.2.0/cd67869a.js">
<link rel="modulepreload" href="./_npm/@turf/boolean-touches@7.2.0/fec9d1db.js">
<link rel="modulepreload" href="./_npm/@turf/boolean-valid@7.2.0/43f9fe1e.js">
<link rel="modulepreload" href="./_npm/@turf/boolean-within@7.2.0/8987ceb8.js">
<link rel="modulepreload" href="./_npm/@turf/buffer@7.2.0/b52ad555.js">
<link rel="modulepreload" href="./_npm/@turf/center@7.2.0/b0d2e8a2.js">
<link rel="modulepreload" href="./_npm/@turf/center-mean@7.2.0/62da1405.js">
<link rel="modulepreload" href="./_npm/@turf/center-median@7.2.0/5f556949.js">
<link rel="modulepreload" href="./_npm/@turf/center-of-mass@7.2.0/a0812a96.js">
<link rel="modulepreload" href="./_npm/@turf/centroid@7.2.0/40f66647.js">
<link rel="modulepreload" href="./_npm/@turf/circle@7.2.0/38962922.js">
<link rel="modulepreload" href="./_npm/@turf/clean-coords@7.2.0/50050321.js">
<link rel="modulepreload" href="./_npm/@turf/clone@7.2.0/5b9e5666.js">
<link rel="modulepreload" href="./_npm/@turf/clusters@7.2.0/02725e0c.js">
<link rel="modulepreload" href="./_npm/@turf/clusters-dbscan@7.2.0/dce96948.js">
<link rel="modulepreload" href="./_npm/@turf/clusters-kmeans@7.2.0/a1392083.js">
<link rel="modulepreload" href="./_npm/@turf/collect@7.2.0/583740aa.js">
<link rel="modulepreload" href="./_npm/@turf/combine@7.2.0/450e9491.js">
<link rel="modulepreload" href="./_npm/@turf/concave@7.2.0/5456880d.js">
<link rel="modulepreload" href="./_npm/@turf/convex@7.2.0/fcb32df7.js">
<link rel="modulepreload" href="./_npm/@turf/destination@7.2.0/2cf8d83b.js">
<link rel="modulepreload" href="./_npm/@turf/difference@7.2.0/b3bc271f.js">
<link rel="modulepreload" href="./_npm/@turf/dissolve@7.2.0/92e350e1.js">
<link rel="modulepreload" href="./_npm/@turf/distance@7.2.0/379bfd17.js">
<link rel="modulepreload" href="./_npm/@turf/distance-weight@7.2.0/9dd80a94.js">
<link rel="modulepreload" href="./_npm/@turf/ellipse@7.2.0/f065242d.js">
<link rel="modulepreload" href="./_npm/@turf/envelope@7.2.0/54b97de8.js">
<link rel="modulepreload" href="./_npm/@turf/explode@7.2.0/8f265ae0.js">
<link rel="modulepreload" href="./_npm/@turf/flatten@7.2.0/0b0c0de3.js">
<link rel="modulepreload" href="./_npm/@turf/flip@7.2.0/fd460e69.js">
<link rel="modulepreload" href="./_npm/@turf/geojson-rbush@7.2.0/8d6139d6.js">
<link rel="modulepreload" href="./_npm/@turf/great-circle@7.2.0/25d5c927.js">
<link rel="modulepreload" href="./_npm/@turf/helpers@7.2.0/28807c9c.js">
<link rel="modulepreload" href="./_npm/@turf/hex-grid@7.2.0/ea1231f4.js">
<link rel="modulepreload" href="./_npm/@turf/interpolate@7.2.0/ea32f970.js">
<link rel="modulepreload" href="./_npm/@turf/intersect@7.2.0/8e2dee51.js">
<link rel="modulepreload" href="./_npm/@turf/invariant@7.2.0/671cab78.js">
<link rel="modulepreload" href="./_npm/@turf/isobands@7.2.0/9fa783c5.js">
<link rel="modulepreload" href="./_npm/@turf/isolines@7.2.0/4cded770.js">
<link rel="modulepreload" href="./_npm/@turf/kinks@7.2.0/74d33a7b.js">
<link rel="modulepreload" href="./_npm/@turf/length@7.2.0/7345f027.js">
<link rel="modulepreload" href="./_npm/@turf/line-arc@7.2.0/8e0ca976.js">
<link rel="modulepreload" href="./_npm/@turf/line-chunk@7.2.0/739150b1.js">
<link rel="modulepreload" href="./_npm/@turf/line-intersect@7.2.0/f0a0b5a4.js">
<link rel="modulepreload" href="./_npm/@turf/line-offset@7.2.0/fa97ca56.js">
<link rel="modulepreload" href="./_npm/@turf/line-overlap@7.2.0/854ada2f.js">
<link rel="modulepreload" href="./_npm/@turf/line-segment@7.2.0/b4b7acd8.js">
<link rel="modulepreload" href="./_npm/@turf/line-slice@7.2.0/eceb9d4b.js">
<link rel="modulepreload" href="./_npm/@turf/line-slice-along@7.2.0/b367e634.js">
<link rel="modulepreload" href="./_npm/@turf/line-split@7.2.0/7a36a297.js">
<link rel="modulepreload" href="./_npm/@turf/line-to-polygon@7.2.0/d0b7f9fe.js">
<link rel="modulepreload" href="./_npm/@turf/mask@7.2.0/adbebaea.js">
<link rel="modulepreload" href="./_npm/@turf/meta@7.2.0/c0f2fe64.js">
<link rel="modulepreload" href="./_npm/@turf/midpoint@7.2.0/4b7d4994.js">
<link rel="modulepreload" href="./_npm/@turf/moran-index@7.2.0/21645c75.js">
<link rel="modulepreload" href="./_npm/@turf/nearest-neighbor-analysis@7.2.0/56d18273.js">
<link rel="modulepreload" href="./_npm/@turf/nearest-point@7.2.0/f9d4c2de.js">
<link rel="modulepreload" href="./_npm/@turf/nearest-point-on-line@7.2.0/84873fda.js">
<link rel="modulepreload" href="./_npm/@turf/nearest-point-to-line@7.2.0/b3b3aed6.js">
<link rel="modulepreload" href="./_npm/@turf/planepoint@7.2.0/ead7e5b7.js">
<link rel="modulepreload" href="./_npm/@turf/point-grid@7.2.0/e76ef64a.js">
<link rel="modulepreload" href="./_npm/@turf/point-on-feature@7.2.0/743222bc.js">
<link rel="modulepreload" href="./_npm/@turf/points-within-polygon@7.2.0/885a2d62.js">
<link rel="modulepreload" href="./_npm/@turf/point-to-line-distance@7.2.0/12dcf0a8.js">
<link rel="modulepreload" href="./_npm/@turf/point-to-polygon-distance@7.2.0/1146de75.js">
<link rel="modulepreload" href="./_npm/@turf/polygonize@7.2.0/49f2665b.js">
<link rel="modulepreload" href="./_npm/@turf/polygon-smooth@7.2.0/441d6e18.js">
<link rel="modulepreload" href="./_npm/@turf/polygon-tangents@7.2.0/16fb2ed1.js">
<link rel="modulepreload" href="./_npm/@turf/polygon-to-line@7.2.0/f6343f87.js">
<link rel="modulepreload" href="./_npm/@turf/projection@7.2.0/f1f9e8a4.js">
<link rel="modulepreload" href="./_npm/@turf/quadrat-analysis@7.2.0/96c1b183.js">
<link rel="modulepreload" href="./_npm/@turf/random@7.2.0/5f84438d.js">
<link rel="modulepreload" href="./_npm/@turf/rectangle-grid@7.2.0/1e58cff0.js">
<link rel="modulepreload" href="./_npm/@turf/rewind@7.2.0/32816f7a.js">
<link rel="modulepreload" href="./_npm/@turf/rhumb-bearing@7.2.0/841df52f.js">
<link rel="modulepreload" href="./_npm/@turf/rhumb-destination@7.2.0/3f05ec15.js">
<link rel="modulepreload" href="./_npm/@turf/rhumb-distance@7.2.0/4567a018.js">
<link rel="modulepreload" href="./_npm/@turf/sample@7.2.0/4a2f4237.js">
<link rel="modulepreload" href="./_npm/@turf/sector@7.2.0/c59573e9.js">
<link rel="modulepreload" href="./_npm/@turf/shortest-path@7.2.0/eeb0627c.js">
<link rel="modulepreload" href="./_npm/@turf/simplify@7.2.0/9c0c4260.js">
<link rel="modulepreload" href="./_npm/@turf/square@7.2.0/9e29a8a2.js">
<link rel="modulepreload" href="./_npm/@turf/square-grid@7.2.0/f2d89276.js">
<link rel="modulepreload" href="./_npm/@turf/standard-deviational-ellipse@7.2.0/d976f68a.js">
<link rel="modulepreload" href="./_npm/@turf/tag@7.2.0/78f4cda9.js">
<link rel="modulepreload" href="./_npm/@turf/tesselate@7.2.0/0c33df1f.js">
<link rel="modulepreload" href="./_npm/@turf/tin@7.2.0/5b8d49a4.js">
<link rel="modulepreload" href="./_npm/@turf/transform-rotate@7.2.0/8132c332.js">
<link rel="modulepreload" href="./_npm/@turf/transform-scale@7.2.0/b9cef896.js">
<link rel="modulepreload" href="./_npm/@turf/transform-translate@7.2.0/ae0121eb.js">
<link rel="modulepreload" href="./_npm/@turf/triangle-grid@7.2.0/2d81daec.js">
<link rel="modulepreload" href="./_npm/@turf/truncate@7.2.0/c6c7893a.js">
<link rel="modulepreload" href="./_npm/@turf/union@7.2.0/45b09bcd.js">
<link rel="modulepreload" href="./_npm/@turf/unkink-polygon@7.2.0/3d73ac69.js">
<link rel="modulepreload" href="./_npm/@turf/voronoi@7.2.0/e53c31bf.js">
<link rel="modulepreload" href="./_npm/@mapbox/geojson-area@0.2.2/97aeb2d0.js">
<link rel="modulepreload" href="./_npm/tinyqueue@2.0.3/904e1d39.js">
<link rel="modulepreload" href="./_npm/geojson-rewind@0.1.0/a5a63eca.js">
<link rel="modulepreload" href="./_npm/osm-polygon-features@0.9.2/678a45f6.js">
<link rel="modulepreload" href="./_npm/global@4.4.0/window.2a4f0ad7.js">
<link rel="modulepreload" href="./_npm/is-function@1.0.2/bcdbad2b.js">
<link rel="modulepreload" href="./_npm/parse-headers@2.0.5/23aa007f.js">
<link rel="modulepreload" href="./_npm/xtend@4.0.2/9320bd14.js">
<link rel="modulepreload" href="./_npm/readable-stream@3.6.2/c0767bad.js">
<link rel="modulepreload" href="./_npm/inherits@2.0.4/0970d8fb.js">
<link rel="modulepreload" href="./_npm/buffer-from@1.1.2/9a323838.js">
<link rel="modulepreload" href="./_npm/typedarray@0.0.6/150d12f6.js">
<link rel="modulepreload" href="./_npm/delaunator@5.0.1/e67acb27.js">
<link rel="modulepreload" href="./_npm/geojson-equality-ts@1.0.2/f892e135.js">
<link rel="modulepreload" href="./_npm/point-in-polygon-hao@1.2.4/7fcd18e4.js">
<link rel="modulepreload" href="./_npm/@turf/jsts@2.7.2/36804be6.js">
<link rel="modulepreload" href="./_npm/d3-geo@1.7.1/c3d5df35.js">
<link rel="modulepreload" href="./_npm/rbush@3.0.1/d425f52b.js">
<link rel="modulepreload" href="./_npm/skmeans@0.9.7/98ef8a0b.js">
<link rel="modulepreload" href="./_npm/concaveman@1.2.1/429c7c90.js">
<link rel="modulepreload" href="./_npm/polyclip-ts@0.16.8/800c7e0e.js">
<link rel="modulepreload" href="./_npm/marchingsquares@1.3.3/8e7df0f4.js">
<link rel="modulepreload" href="./_npm/sweepline-intersections@1.5.0/96af2410.js">
<link rel="modulepreload" href="./_npm/fast-deep-equal@3.1.3/f66fa298.js">
<link rel="modulepreload" href="./_npm/earcut@2.2.4/5845decc.js">
<link rel="modulepreload" href="./_npm/d3-voronoi@1.1.2/555fe511.js">
<link rel="modulepreload" href="./_npm/wgs84@0.0.0/307a0e2e.js">
<link rel="modulepreload" href="./_npm/geojson-area@0.1.0/be7de90b.js">
<link rel="modulepreload" href="./_npm/util-deprecate@1.0.2/cacd7a6b.js">
<link rel="modulepreload" href="./_npm/string_decoder@1.3.0/f202c26f.js">
<link rel="modulepreload" href="./_npm/robust-predicates@3.0.2/8ac9039b.js">
<link rel="modulepreload" href="./_npm/quickselect@2.0.0/551b5bfb.js">
<link rel="modulepreload" href="./_npm/point-in-polygon@1.1.0/ad8ad71d.js">
<link rel="modulepreload" href="./_npm/robust-predicates@2.0.4/umd/orient2d.min.js.3c911427.js">
<link rel="modulepreload" href="./_npm/bignumber.js@9.1.2/87ba5c5f.js">
<link rel="modulepreload" href="./_npm/splaytree-ts@1.0.2/6ce28fb5.js">
<link rel="modulepreload" href="./_npm/safe-buffer@5.2.1/200e0b31.js">
<link rel="icon" href="./_file/observable.1af93621.png" type="image/png" sizes="32x32">
<script type="module">

import {define} from "./_observablehq/client.f5ee32d5.js";
import {registerFile} from "./_observablehq/stdlib.2229c972.js";

registerFile("./@mbrickmaps/ne-10m/10m_coastline.json", {"name":"./@mbrickmaps/ne-10m/10m_coastline.json","mimeType":"application/json","path":"./@mbrickmaps/ne-10m/10m_coastline.json"});
registerFile("./@mbrickmaps/ne-10m/ne_10m_admin_0_countries_usa (1) (1).json", {"name":"./@mbrickmaps/ne-10m/ne_10m_admin_0_countries_usa (1) (1).json","mimeType":"application/json","path":"./_file/@mbrickmaps/ne-10m/ne_10m_admin_0_countries_usa (1) (1).ac90eeaa.json","lastModified":1664292493523,"size":19759918});
registerFile("./@mbrickmaps/ne-10m/ne_10m_admin_1_states_provinces.json", {"name":"./@mbrickmaps/ne-10m/ne_10m_admin_1_states_provinces.json","mimeType":"application/json","path":"./_file/@mbrickmaps/ne-10m/ne_10m_admin_1_states_provinces.76c23f73.json","lastModified":1681830880595,"size":1946371});
registerFile("./@mbrickmaps/ne-10m/ne_10m_lakes (1).json", {"name":"./@mbrickmaps/ne-10m/ne_10m_lakes (1).json","mimeType":"application/json","path":"./_file/@mbrickmaps/ne-10m/ne_10m_lakes (1).667c6332.json","lastModified":1663955314769,"size":2622274});
registerFile("./@mbrickmaps/ne-10m/ne_10m_populated_places.json", {"name":"./@mbrickmaps/ne-10m/ne_10m_populated_places.json","mimeType":"application/json","path":"./_file/@mbrickmaps/ne-10m/ne_10m_populated_places.4100e12d.json","lastModified":1663349609374,"size":18219570});
registerFile("./@mbrickmaps/ne-10m/ocean.json", {"name":"./@mbrickmaps/ne-10m/ocean.json","mimeType":"application/json","path":"./_file/@mbrickmaps/ne-10m/ocean.d6bfc4b7.json","lastModified":1673630389051,"size":4045486});

define({id: "264cc6da", inputs: ["FileAttachment"], outputs: ["c","p","pr","lakes","oceans","coastlines","queryOverpass","DOM","d3Base","d3GeoProjection","d3GeoPolygon","d3GeoScaleBar","d3Array","proj4","turf","geojsonrewind","topoClient","topoSimplify","topoSever","polylabel","d3","topojson"], body: async (FileAttachment) => {
const [{default: queryOverpass}, {DOM}, d3Base, d3GeoProjection, d3GeoPolygon, d3GeoScaleBar, d3Array, proj4, turf, geojsonrewind, topoClient, topoSimplify, topoSever, polylabel] = await Promise.all([import("./_npm/query-overpass@1.5.5/69ce1f03.js"), import("./_observablehq/stdlib.2229c972.js"), import("./_npm/d3@7.9.0/7055d4c5.js"), import("./_npm/d3-geo-projection@2.9.0/ef1109a2.js"), import("./_npm/d3-geo-polygon@2.0.1/d02baae9.js"), import("./_npm/d3-geo-scale-bar@1.2.5/273332d7.js"), import("./_npm/d3-array@3.2.4/e95f898e.js"), import("./_npm/proj4@2.7.5/034b033c.js"), import("./_npm/@turf/turf@7.2.0/430a7ea5.js"), import("./_npm/geojson-rewind@0.3.1/7d5b99d1.js"), import("./_npm/topojson-client@3.1.0/44d97fcb.js"), import("./_npm/topojson-simplify@3.0.3/fd9926cb.js"), import("./_npm/topojson-server@3.0.1/470bdfd4.js"), import("./_npm/polylabel@1.1.0/03ffa5c3.js")]);
const c = FileAttachment("./@mbrickmaps/ne-10m/ne_10m_admin_0_countries_usa (1) (1).json").json()
const p = FileAttachment("./@mbrickmaps/ne-10m/ne_10m_populated_places.json").json()
const pr = FileAttachment("./@mbrickmaps/ne-10m/ne_10m_admin_1_states_provinces.json").json()

const lakes = FileAttachment("./@mbrickmaps/ne-10m/ne_10m_lakes (1).json").json()
const oceans = FileAttachment("./@mbrickmaps/ne-10m/ocean.json").json()
const coastlines = FileAttachment("./@mbrickmaps/ne-10m/10m_coastline.json").json() 





// Create combined namespace called d3
const d3 = Object.assign({}, 
    d3Base, 
    d3GeoProjection, 
    d3GeoPolygon, 
    d3GeoScaleBar,
    d3Array
);

const topojson = Object.assign({}, 
    topoClient, 
    topoSimplify, 
    topoSever, 
);
return {c,p,pr,lakes,oceans,coastlines,queryOverpass,DOM,d3Base,d3GeoProjection,d3GeoPolygon,d3GeoScaleBar,d3Array,proj4,turf,geojsonrewind,topoClient,topoSimplify,topoSever,polylabel,d3,topojson};
}});

define({id: "25c8f605", inputs: ["topojson","c","pr","p","d3","lakes"], outputs: ["countries","provinces","places","defaultSettings"], body: (topojson,c,pr,p,d3,lakes) => {
const countries = topojson.feature(c,c.objects.ne_10m_admin_0_countries_usa).features
const provinces = topojson.feature(pr,pr.objects.ne_10m_admin_1_states_provinces).features
const places = topojson.feature(p,p.objects.ne_10m_populated_places).features

const defaultSettings = ({
  width: 1152,
  height: null,
  bounds: {
    bounder: false,
    countries: null,
    feature: {
      type: "Feature",
      properties: {},
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [0, -90],
            [0, 90],
            [180, 90],
            [180, -90],
            [0, -90]
          ]
        ]
      }
    }
  },
  clipping: {
    clip: false,
    margin: 0
  },
  projection: {
    type: "default",
    proj: d3.geoMiller(),
    fit: "size",
    translate: false, // [this.width / 2, this.height / 2]
    scale: false, // 5000
    center: false, // []
    rotate: false, // [0,0,0]
    tilt: false, //
    distance: false,
    clipExtent: false,
    clipAngle: false,
    precision: false
  },
  rotation: {
    value: [0, 0, 0],
    rotate: false
  },
  basemap: {
    coastline: {
      show: true,
      style: { fill: "none", stroke: "#dddddd", opacity: 1 }
    },
    background: {
      show: false,
      style: { fill: "#ffffff", stroke: "none", opacity: 1 }
    },
    land: {
      show: true,
      geometry: countries,
      key: "GID_0",
      label: "NAME_0",
      style: { fill: "#fffff9", stroke: "none", opacity: 1 }
    },
    border: {
      show: true,
      geometry: countries,
      style: { fill: "none", stroke: "#dedede ", opacity: 1 }
    },
    ocean: {
      show: true,
      geometry: null,
      style: { fill: "#f2f2f2", stroke: "none", opacity: 1 }
    },
    lake: {
      show: true,
      geometry: lakes,
      style: { fill: "#f2f2f2", stroke: "none", opacity: 1, "stroke-width": 1 }
    },
    river: {
      show: false,
      geometry: null,
      style: { fill: "none", stroke: "blue", opacity: 1 }
    },
    graticule: {
      show: false,
      style: { fill: "none", stroke: "gray", opacity: 1 }
    }
  },
  graticule: {
    step: null, //10
    show: false,
    custom: {
      gc: true,
      show: true,
      latitude: [66.5], // Tropic of Cancer, Equator, Arctic Circle
      longitude: [],
      latBounds: [-93.5, 14],
      lonBounds: [50, 83],
      style: {
        stroke: "#0a1f35",
        "stroke-width": 1,
        opacity: 1,
        "stroke-dasharray": "none"
      }
    }
  },
  layer: {
    points: { show: false, data: null }, //[{}]}, points
    polys: { show: false, data: null }, //polygons polylines
    tiles: { show: false, data: null }, //[{id: type: delta:}] },
    grids: { show: false, data: null }
  },
  scalebar: {
    show: false,
    topValue: 200,
    topUnit: "km",
    bottomValue: 200,
    bottomUnit: "mi",
    position: [120, 50]
  },
  label: {
    show: false,
    country: null, //[] list of names
    style: null // {}
  },
  graphic: {
    width: null,
    height: null,
    title: {
      show: false,
      text: null
    },
    subtitle: {
      show: false,
      text: null
    },
    note: {
      show: false,
      text: null
    },
    logo: {
      show: false,
      text: null
    },
    template: null //{}
  }
})
return {countries,provinces,places,defaultSettings};
}});

define({id: "b5a42bc1", inputs: ["d3"], outputs: ["customSettings"], body: (d3) => {
const customSettings = ({
  width: 680,
  height: null,
  bounds: {
    bounder: false,
    countries: null,
    feature: {
      type: "Feature",
      properties: {},
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [0, -90],
            [0, 90],
            [180, 90],
            [180, -90],
            [0, -90]
          ]
        ]
      }
    }
  },
  clipping: {
    clip: true,
    margin: 0
  },
  projection: {
    type: "default",
    proj: d3.geoMercator(),
    fit: "size",
    translate: false, // [this.width / 2, this.height / 2]
    scale: false, // 5000
    center: false, // []
    rotate: false, // [0,0,0]
    tilt: false, //
    distance: false,
    clipExtent: false,
    clipAngle: false,
    precision: false
  },
  rotation: {
    value: [0, 0, 0],
    rotate: false
  },
  layer: {
    points: { show: false, data: null },
    polys: { show: false, data: null },
    tiles: { show: false, data: null },
    grids: { show: false, data: null }
  },
  basemap: {
    coastline: {
      show: true,
      style: { fill: "none", stroke: "#18294b", opacity: 1 }
    },
    background: {
      show: false,
      style: { fill: "#f2f2f2", stroke: "none", opacity: 1 }
    },
    land: {
      show: true,
      geometry: null,
      key: "GID_0",
      label: "NAME_0",
      style: { fill: "#f8d8aa", stroke: "none", opacity: 1 }
    },
    border: {
      show: true,
      geometry: null,
      style: { fill: "none", stroke: "#35281f", opacity: 1 }
    },
    ocean: {
      show: true,
      geometry: null,
      style: { fill: "#b6c3b0", stroke: "none", opacity: 1 }
    },
    lake: {
      show: true,
      geometry: null,
      style: { fill: "#688581", stroke: "none", opacity: 1, "stroke-width": 1 }
    },
    river: {
      show: true,
      geometry: null,
      style: { fill: "none", stroke: "blue", opacity: 1 }
    },
    graticule: {
      show: false
    }
  },
  graticule: {
    step: null, //10
    show: false,
    custom: {
      gc: true,
      show: true,
      latitude: [66.5], // Tropic of Cancer, Equator, Arctic Circle
      longitude: [],
      latBounds: [-93.5, 14],
      lonBounds: [50, 83],
      style: {
        stroke: "#0a1f35",
        "stroke-width": 1,
        opacity: 1,
        "stroke-dasharray": "none"
      }
    }
  },
  scalebar: {
    show: false,
    topValue: 200,
    topUnit: "km",
    bottomValue: 200,
    bottomUnit: "mi",
    position: [120, 50]
  },
  label: {
    show: false,
    country: null, //[] list of names
    style: null // {}
  }
})
return {customSettings};
}});

define({id: "4b1a18a7", inputs: ["d3"], outputs: ["aagSettings"], body: (d3) => {
const aagSettings = ({
  width: 1152,
  height: null,
  bounds: {
    bounder: false,
    countries: null,
    feature: {
      type: "Feature",
      properties: {},
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [0, -90],
            [0, 90],
            [180, 90],
            [180, -90],
            [0, -90]
          ]
        ]
      }
    }
  },
  clipping: {
    clip: false,
    margin: 0
  },
  projection: {
    type: "default",
    proj: d3.geoMiller(),
    fit: "size",
    translate: false, // [this.width / 2, this.height / 2]
    scale: false, // 5000
    center: false, // []
    rotate: false, // [0,0,0]
    tilt: false, //
    distance: false,
    clipExtent: false,
    clipAngle: false,
    precision: false
  },
  rotation: {
    value: [0, 0, 0],
    rotate: false
  },
  basemap: {
    coastline: {
      show: false,
      style: { fill: "none", stroke: "#dddddd", opacity: 1 }
    },
    background: {
      show: false,
      style: { fill: "#f2f2f2", stroke: "none", opacity: 1 }
    },
    land: {
      show: true,
      geometry: null,
      key: "GID_0",
      label: "NAME_0",
      style: {
        fill: function (d) {
          if (d.properties.ISO_A2 == "IR") {
            return "#ebe4d0";
          } else {
            return "#fffff9";
          }
        },
        stroke: "none",
        opacity: 0.85
      }
    },
    border: {
      show: true,
      geometry: null,
      style: { fill: "none", stroke: "#CCCCCC", opacity: 1 }
    },
    ocean: {
      show: false,
      geometry: null,
      style: { fill: "#f2f2f2", stroke: "none", opacity: 1 }
    },
    lake: {
      show: true,
      geometry: null,
      style: { fill: "#f2f2f2", stroke: "none", opacity: 1, "stroke-width": 1 }
    },
    river: {
      show: false,
      geometry: null,
      style: { fill: "none", stroke: "blue", opacity: 1 }
    },
    graticule: {
      show: false
    }
  },
  graticule: {
    step: null, //10
    show: false,
    custom: {
      show: false,
      latitude: {
        min: null,
        max: null
      },
      longitude: {
        min: null,
        max: null
      },
      style: {
        stroke: "red",
        "stroke-width": 1,
        opacity: 1,
        "stroke-dasharray": "none"
      }
    }
  },
  layer: {
    points: { show: false, data: null }, //[{}]}, points
    polys: { show: false, data: null }, //polygons polylines
    tiles: { show: false, data: null }, //[{id: type: delta:}] },
    grids: { show: false, data: null }
  },
  scalebar: {
    show: false,
    topValue: 200,
    topUnit: "km",
    bottomValue: 200,
    bottomUnit: "mi",
    position: [120, 50]
  },
  label: {
    show: false,
    country: null, //[] list of names
    style: null // {}
  }
})
return {aagSettings};
}});

define({id: "2e8be929", inputs: ["view","Mapa"], body: (view,Mapa) => {
view(new Mapa())
view(new Mapa().render)
}});

define({id: "a5f908ce", inputs: ["defaultSettings","topojson","proj4","d3","countries","turf","oceans","c","coastlines","lakes"], outputs: ["Mapa"], body: (defaultSettings,topojson,proj4,d3,countries,turf,oceans,c,coastlines,lakes) => {
class Mapa {
  constructor(
    props = {
      width: null,
      height: null,
      bounds: null,
      clipping: null,
      projection: null,
      rotation: null,
      basemap: null,
      layer: {
        points: { show: false, data: null },
        polys: { show: false, data: null },
        tiles: { show: false, data: null },
        grids: { show: false, data: null }
      },
      scalebar: null,
      label: null,
      style: null,
      graphic: null
    }
  ) {
    this.width = props.width ? props.width : defaultSettings.width;
    this.height = props.height ? props.height : defaultSettings.height;
    this.basemap = props.basemap ? props.basemap : defaultSettings.basemap;
    this.projection = props.projection
      ? props.projection
      : defaultSettings.projection;
    this.rotation = props.rotation ? props.rotation : defaultSettings.rotation;
    this.layer = props.layer ? props.layer : defaultSettings.layer;
    this.scalebar = props.scalebar ? props.scalebar : defaultSettings.scalebar;
    this.bounds = props.bounds ? props.bounds : defaultSettings.bounds;
    this.clipping = props.clipping ? props.clipping : defaultSettings.clipping;
    this.label = props.label ? props.label : defaultSettings.label;
    this.graphic = props.graphic ? props.graphic : defaultSettings.graphic;
  }
  get render() {
    class Layer {
      constructor(
        props = {
          geometry: null,
          style: null,
          group: null,
          path: null,
          type: null,
          scale: null
        }
      ) {
        this.geometry = props.geometry ? props.geometry : null;
        this.filter = props.filter
          ? props.filter
          : { show: null, key: null, value: null };
        this.style = props.style
          ? props.style
          : {
              stroke: null,
              "stroke-dasharray": null,
              "stroke-dashoffset": null,
              "stroke-linecap": null,
              "stroke-linejoin": null,
              "stroke-miterlimit": null,
              "stroke-opacity": null,
              "stroke-width": null,
              fill: null,
              radius: null,
              "fill-opacity": null,
              opacity: null,
              type: null
            };
        this.group = props.group ? props.group : null;
        this.path = props.path;
        this.type = props.type ? props.type : null;
        this.scale = props.scale ? props.scale : null;
      }
      get add() {
        let filter = this.filter;
        let group = this.group;
        let geometry = this.geometry;
        let style = this.style;
        let path = this.path;
        let layer = this.layer;
        let data = null;
        let scale = this.scale;
        let type = this.type;
        if (this.type == "Point") {
          return group
            .append("g")
            .selectAll("circle")
            .data(geometry)
            .enter()
            .append("circle")
            .attr("cx", (d) => projection(d.geometry.coordinates)[0])
            .attr("cy", (d) => projection(d.geometry.coordinates)[1])
            .attr("r", this.style.radius ?? "4") // Set the radius here
            .attr("stroke-opacity", this.style["stroke-opacity"] ?? "1")
            .attr("stroke", this.style["stroke"] ?? "black")
            .attr("stroke-width", this.style["stroke-width"] ?? "none")
            .attr("fill", this.style.fill ?? "none")
            .attr("fill-opacity", this.style["fill-opacity"] ?? "1");
        } else if (this.geometry.type == "Topology") {
          data = topojson.feature(
            geometry,
            geometry.objects[Object.keys(geometry.objects)[0]] // 😅
          ).features;

          if (filter.show) {
            data = data.filter(function (d) {
              console.log(filter.key, d.properties, d.properties[filter.key]);
              if (d.properties[filter.key] == filter.value) {
                return d;
              }
            });

            //console.log(data.length);
          }
          return group
            .append("g")
            .selectAll("path")
            .data(data)
            .enter()
            .append("path")
            .attr("d", path)
            .attr("stroke", this.style.stroke ? this.style.stroke : "none")
            .attr(
              "stroke-dasharray",
              this.style["stroke-dasharray"]
                ? this.style["stroke-dasharray"]
                : "none"
            )
            .attr(
              "stroke-dashoffset",
              this.style["stroke-dashoffset"]
                ? this.style["stroke-dashoffset"]
                : "none"
            )
            .attr(
              "stroke-linecap",
              this.style["stroke-linecap"]
                ? this.style["stroke-linecap"]
                : "round"
            )
            .attr(
              "stroke-linejoin",
              this.style["stroke-linejoin"]
                ? this.style["stroke-linejoin"]
                : "round"
            )
            .attr(
              "stroke-miterlimit",
              this.style["stroke-miterlimit"]
                ? this.style["stroke-miterlimit"]
                : "4"
            )
            .attr(
              "stroke-opacity",
              this.style["stroke-opacity"] ? this.style["stroke-opacity"] : "1"
            )
            .attr(
              "stroke-width",
              this.style["stroke-width"] ? this.style["stroke-width"] : "none"
            )
            .attr("fill", this.style.fill ? this.style.fill : "none")
            .attr(
              "fill-opacity",
              this.style["fill-opacity"] ? this.style["fill-opacity"] : "1"
            )
            .attr("opacity", this.style.opacity ? this.style.opacity : "1");
        } else {
          if (this.type == "qtree") {
            return group
              .append("g")
              .selectAll("circle")
              .data(geometry)
              .enter()
              .append("circle")
              .attr("cx", (d) => {
                return projection(d.geometry.coordinates)[0];
              })
              .attr("cy", (d) => {
                return projection(d.geometry.coordinates)[1];
              })
              .attr("r", (d) => {
                return scale(d.properties.count);
              })
              .attr("data-count", (d) => {
                return d.properties.count;
              })
              .attr(
                "stroke-opacity",
                this.style["stroke-opacity"]
                  ? this.style["stroke-opacity"]
                  : "1"
              )
              .attr(
                "stroke",
                this.style["stroke"] ? this.style["stroke"] : "black"
              )
              .attr(
                "stroke-width",
                this.style["stroke-width"] ? this.style["stroke-width"] : "none"
              )
              .attr("fill", this.style.fill ? this.style.fill : "none")
              .attr(
                "fill-opacity",
                this.style["fill-opacity"] ? this.style["fill-opacity"] : "1"
              );
          } else {
            return group
              .append("g")
              .selectAll("path")
              .data(geometry)
              .enter()
              .append("path")
              .attr("d", path)
              .attr("stroke", this.style.stroke ? this.style.stroke : "none")
              .attr(
                "stroke-dasharray",
                this.style["stroke-dasharray"]
                  ? this.style["stroke-dasharray"]
                  : "none"
              )
              .attr(
                "stroke-dashoffset",
                this.style["stroke-dashoffset"]
                  ? this.style["stroke-dashoffset"]
                  : "none"
              )
              .attr(
                "stroke-linecap",
                this.style["stroke-linecap"]
                  ? this.style["stroke-linecap"]
                  : "butt"
              )
              .attr(
                "stroke-linejoin",
                this.style["stroke-linejoin"]
                  ? this.style["stroke-linejoin"]
                  : "round"
              )
              .attr(
                "stroke-miterlimit",
                this.style["stroke-miterlimit"]
                  ? this.style["stroke-miterlimit"]
                  : "4"
              )
              .attr(
                "stroke-opacity",
                this.style["stroke-opacity"]
                  ? this.style["stroke-opacity"]
                  : "1"
              )
              .attr(
                "stroke-width",
                this.style["stroke-width"] ? this.style["stroke-width"] : "none"
              )
              .attr("fill", this.style.fill ? this.style.fill : "none")
              .attr(
                "fill-opacity",
                this.style["fill-opacity"] ? this.style["fill-opacity"] : "1"
              )
              .attr("opacity", this.style.opacity ? this.style.opacity : "1");
          }
        }
      }
    }
    let uid = Math.random().toString(36).substr(2, 5);

    let margin = this.clipping.margin;
    let width = this.width;
    let height = this.height;
    let basemap = this.basemap;

    const sphere = { type: "Sphere" };
    const country = this.basemap.land.geometry;

    let projection = this.projection.proj;

    if (this.projection.type == "proj4") {
      function degreesToRadians(degrees) {
        return (degrees * Math.PI) / 180;
      }
      function radiansToDegrees(radians) {
        return (radians * 180) / Math.PI;
      }

      let check = this.projection.proj.split(" ");
      for (let x of ["+x_0=0", "+y_0=0"]) {
        if (check.indexOf(x) == -1) {
          check.push(x);
        }
      }
      projection = check.join(" ");

      let projTarget = proj4(projection);
      let project4 = function (lambda, phi) {
        return projTarget.forward([lambda, phi].map(radiansToDegrees));
      };
      project4.invert = function (x, y) {
        return projTarget.inverse([x, y]).map(degreesToRadians);
      };

      projection = d3
        .geoProjection(project4)
        .fitExtent(
          [
            [0, 0],
            [width, height]
          ],
          this.bounds.feature
        )
        .preclip(d3.geoClipAntimeridian); //
    }

    if (this.projection.type == "raw") {
      projection = this.projection.proj;
    }

    if (this.projection.type == "clip") {
      projection = this.projection.proj.clipAngle(180);
    }

    if (this.projection.type == "custom") {
      projection = this.projection.proj
        .translate(this.projection.translate)
        .scale(this.projection.scale)
        .center(this.projection.center)
        .rotate(this.projection.rotate)
        .tilt(this.projection.tilt)
        .distance(this.projection.distance)
        .clipAngle(this.projection.clipAngle)
        .precision(this.projection.precision);
    }

    if (height == null) {
      const [[x0, y0], [x1, y1]] = d3
        .geoPath(projection.fitWidth(width, sphere))
        .bounds(sphere);
      const dy = Math.ceil(y1 - y0),
        l = Math.min(Math.ceil(x1 - x0), dy);
      projection.scale((projection.scale() * (l - 1)) / l).precision(0.2);
      height = dy;
    }

    if (this.projection.fit == "none") {
    }

    if (this.bounds.bounder) {
      projection.fitSize([width, height], this.bounds.feature);
    }

    if (this.projection.fit == "iso2") {
      if (this.bounds.countries.length > 0) {
        let list = this.bounds.countries;
        let filteredCountries = countries.filter(function (d, i) {
          if (list.indexOf(d.properties.ISO_A2) > -1) {
            return d;
          }
        });

        projection.fitSize(
          [width, height],
          turf.featureCollection(filteredCountries)
        );
      }
    }

    if (this.projection.fit == "iso3") {
      if (this.bounds.countries.length > 0) {
        let list = this.bounds.countries;
        let filteredCountries = countries.filter(function (d, i) {
          if (list.indexOf(d.properties.ISO_A3) > -1) {
            return d;
          }
        });

        projection.fitSize(
          [width, height],
          turf.featureCollection(filteredCountries)
        );
      }
    }

    if (this.projection.fit == "size") {
      projection.fitSize([width, height], sphere);
    }
    if (this.projection.fit == "extent") {
      projection.fitExtent(
        [
          [0, 0],
          [width, height]
        ],
        sphere
      );
    }

    if (this.clipping.clip) {
      function viewport() {
        let n = 15;
        let p = -1 * margin;

        return {
          type: "Polygon",
          coordinates: [
            [
              ...Array.from({ length: n }, (_, t) => [
                p + ((width - p * 2) * t) / n,
                p
              ]),
              ...Array.from({ length: n }, (_, t) => [
                width - p,
                ((height - p * 2) * t) / n + p
              ]),
              ...Array.from({ length: n }, (_, t) => [
                p + ((width - p * 2) * (n - t)) / n,
                height - p
              ]),
              ...Array.from({ length: n }, (_, t) => [
                p,
                ((height - p * 2) * (n - t)) / n + p
              ]),
              [p, p]
            ].map((p) => projection.invert(p))
          ]
        };
      }
      let v = {
        type: "Polygon",
        coordinates: [
          viewport().coordinates[0].map(d3.geoRotation(projection.rotate()))
        ]
      };
      let clipPolygon = d3.geoClipPolygon(v);
      projection.preclip(clipPolygon);
    }

    let path = d3.geoPath().projection(projection);

    let rotation = this.rotation.value;
    if (this.rotation.value instanceof Array) {
      rotation = this.rotation.value;
    } else {
      rotation = [this.rotation.value, 0, 0];
    }
    if (this.rotation.rotate) {
      projection.rotate(rotation);
    }

      // Create and setup SVG with UID
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    let layers = this.layers;
    const graphic = d3
      .select(svg)
      .attr("width", width)
      .attr("height", height)
      .attr("id", uid)  // Using the UID as id
      .attr("id", "graphic")
      .attr("vector-effect", "non-scaling-stroke")
      .attr("stroke-linejoin", "round");

    let graster = graphic.append("g").attr("id", "rasterlayer"); //bottom
    let gbasemap = graphic.append("g").attr("id", "basemap");
    let glayer = graphic.append("g").attr("id", "layers");
    let gsymbol = graphic.append("g").attr("id", "symbols");
    let glabel = graphic.append("g").attr("id", "labels");
    let gscalebar = graphic.append("g").attr("id", "scalebar");
    let gannotation = graphic.append("g").attr("id", "annotations"); //top
    let ggrid = graphic.append("g").attr("id", "grid");

    graster.append("g").attr("id", "raster");

    let scalebar = this.scalebar;
    if (scalebar.show) {
      const mapUnits = {
        km: d3.geoScaleKilometers,
        mi: d3.geoScaleMiles,
        ft: d3.geoScaleFeet,
        m: d3.geoScaleMeters,
        kilometers: d3.geoScaleKilometers,
        miles: d3.geoScaleMiles,
        feet: d3.geoScaleFeet,
        meters: d3.geoScaleMeters
      };
      const mapScale = gscalebar
        .append("g")
        .attr(
          "transform",
          `translate(${width - scalebar.position[0]}, ${
            height - scalebar.position[1]
          })`
        );

      var stop = 0;
      var sleft = 0;

      const scaleBarTop = d3
        .geoScaleBar()
        .projection(projection)
        .size([width, height])
        .orient(d3.geoScaleTop)
        .units(mapUnits[scalebar.topUnit])
        .distance(scalebar.topValue)
        .left(sleft)
        .top(stop)
        .label(null)
        .tickPadding(3)
        .tickFormat((d, i, e) =>
          i === e.length - 1 ? `${d} ${scalebar.topUnit}` : d
        )
        .tickValues([0, scalebar.topValue]);

      const scaleBarBottom = d3
        .geoScaleBar()
        .projection(projection)
        .size([width, height])
        .units(mapUnits[scalebar.bottomUnit])
        .orient(d3.geoScaleBottom)
        .distance(scalebar.bottomValue)
        .left(sleft)
        .top(stop)
        .label(null)
        .tickPadding(3)
        .tickFormat((d, i, e) =>
          i === e.length - 1 ? `${d} ${scalebar.bottomUnit}` : d
        )
        .tickValues([0, scalebar.bottomValue]);

      const myscaleTop = mapScale
        .append("g")
        .attr("id", "scalebart")
        .attr("transform", "translate(0, -5)");

      const myscaleBottom = mapScale
        .append("g")
        .attr("id", "scalebarb")
        .attr("transform", "translate(0, 5)");

      myscaleTop.call(scaleBarTop);
      myscaleBottom.call(scaleBarBottom);

      myscaleTop.selectAll("rect").remove();
      myscaleBottom.selectAll("rect").remove();

      myscaleTop.selectAll("path, line").attr("stroke", "#4B535D");
      myscaleBottom.selectAll("path, line").attr("stroke", "#4B535D");

      myscaleTop
        .selectAll(".tick")
        .select("text")
        .attr("text-anchor", "start")
        .attr("dx", function (d, i) {
          if (d < 1) {
            return -3.5;
          } else {
            return -4 * +d.toString().length;
          }
        })
        .attr("font-size", 14)
        .attr("fill", "#4B535D");

      myscaleBottom
        .selectAll(".tick")
        .select("text")
        .attr("text-anchor", "start")
        .attr("dx", function (d, i) {
          if (d < 1) {
            return -3.5;
          } else {
            return -4 * +d.toString().length;
          }
        })
        .attr("font-size", 14)
        .attr("fill", "#4B535D");
    }

    if (basemap.background.show) {
      let globeRect = {
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: [
            [
              [-180, -90],
              [-180, 90],
              [180, 90],
              [180, -90],
              [-180, -90]
            ]
          ]
        }
      };

      gbasemap
        .append("g")
        .attr("id", "background")
        .selectAll("path")
        .data([globeRect])
        .join("path")
        .attr(
          "stroke",
          this.basemap.background.style.stroke
            ? this.basemap.background.style.stroke
            : "none"
        )
        .attr(
          "fill",
          this.basemap.background.style.fill
            ? this.basemap.background.style.fill
            : "none"
        )
        .attr(
          "opacity",
          this.basemap.background.style.opacity
            ? this.basemap.background.style.opacity
            : "1"
        )
        .attr("d", path);
    }
    if (basemap.ocean.show) {
      gbasemap
        .append("g")
        .attr("id", "ocean")
        .selectAll("path")
        .data(oceans)
        .join("path")
        .attr(
          "stroke",
          this.basemap.ocean.style.stroke
            ? this.basemap.ocean.style.stroke
            : "none"
        )
        .attr(
          "fill",
          this.basemap.ocean.style.fill ? this.basemap.ocean.style.fill : "none"
        )
        .attr(
          "opacity",
          this.basemap.ocean.style.opacity
            ? this.basemap.ocean.style.opacity
            : "1"
        )
        .attr("d", path);
    }
    if (basemap.land.show) {
      gbasemap
        .append("g")
        .attr("id", "land")
        .selectAll("path")
        .data(countries)
        .join("path")
        .attr(
          "stroke",
          this.basemap.land.style.stroke
            ? this.basemap.land.style.stroke
            : "none"
        )
        .attr(
          "stroke-width",
          this.basemap.land.style["stroke-width"]
            ? this.basemap.land.style["stroke-width"]
            : "none"
        )
        .attr(
          "fill",
          this.basemap.land.style.fill ? this.basemap.land.style.fill : "none"
        )
        .attr(
          "opacity",
          this.basemap.land.style.opacity
            ? this.basemap.land.style.opacity
            : "1"
        )
        .attr("d", path)
        .on("click", mouseClick);

      function mouseClick() {
        let tar = d3.select(this).data()[0];
        console.log(tar.properties.NAME);
      }
    }
    if (basemap.border.show) {
      gbasemap
        .append("path")
        .attr("id", "border")
        .datum(
          topojson.mesh(
            c,
            c.objects.ne_10m_admin_0_countries_usa,
            function (a, b) {
              return a !== b;
            }
          )
        )
        .attr(
          "stroke",
          this.basemap.border.style.stroke
            ? this.basemap.border.style.stroke
            : "none"
        )
        .attr(
          "stroke-width",
          this.basemap.border.style["stroke-width"]
            ? this.basemap.border.style["stroke-width"]
            : "1"
        )
        .attr("fill", "none")
        .attr(
          "opacity",
          this.basemap.border.style.opacity
            ? this.basemap.border.style.opacity
            : "1"
        )
        .attr("d", path);
    }
    if (basemap.coastline.show) {
      gbasemap
        .append("g")
        .attr("id", "coastline")
        .selectAll("path")
        .data(coastlines)
        .join("path")
        .attr(
          "stroke",
          this.basemap.coastline.style.stroke
            ? this.basemap.coastline.style.stroke
            : "none"
        )
        .attr(
          "stroke-width",
          this.basemap.coastline.style["stroke-width"]
            ? this.basemap.coastline.style["stroke-width"]
            : "none"
        )
        .attr("fill", "none")
        .attr(
          "opacity",
          this.basemap.coastline.style.opacity
            ? this.basemap.coastline.style.opacity
            : "1"
        )
        .attr("d", path);
    }
    if (basemap.lake.show) {
      gbasemap
        .append("g")
        .attr("id", "lakes")
        .selectAll("path")
        .data(lakes)
        .join("path")
        .attr("stroke", "none")
        .attr(
          "stroke-width",
          this.basemap.lake.style["stroke-width"]
            ? this.basemap.lake.style["stroke-width"]
            : "none"
        )
        .attr(
          "fill",
          this.basemap.lake.style.fill ? this.basemap.lake.style.fill : "none"
        )
        .attr(
          "opacity",
          this.basemap.lake.style.opacity
            ? this.basemap.lake.style.opacity
            : "1"
        )
        .attr("d", path);
    }

    if (this.layer.polys.show) {
      for (let l in this.layer.polys.data) {
        console.log(this.layer.polys.data[l]);
        new Layer({
          geometry: this.layer.polys.data[l].geometry,
          group: glayer,
          style: this.layer.polys.data[l].style,
          type: this.layer.polys.data[l].style.type
            ? this.layer.polys.data[l].style.type
            : "null",
          path: path,
          filter: this.layer.polys.data[l].filter
            ? this.layer.polys.data[l].filter
            : { show: false }
        }).add;
      }
    }

    if (this.layer.tiles.show) {
      let filter = null;
      let url = null;
      let format = null;
      let tiles = this.layer.tiles.data;
      for (let t in tiles) {
        if (tiles[t].show) {
          let raster = graster
            .append("g")
            .attr("id", "tiles-" + uid + "-" + tiles[t].id);

          if (typeof tiles[t].filter !== undefined) {
            filter = tiles[t].filter;
          }
          url = tiles[t].url ? tiles[t].url : null;
          format = tiles[t].format ? tiles[t].format : null;
          let zoom = tiles[t].zoom ? tiles[t].zoom : null;
          let tileset = getTiles(tiles[t].type, zoom, filter);
          let slippy = geoTile().size([width, height]).tileSet(tileset);

          if (typeof tiles[t].delta == "number") {
            slippy = geoTile(tiles[t].delta)
              .size([width, height])
              .tileSet(tileset);
          }

          slippy.projection(projection);
          raster.call(slippy.tile);
        }
      }
      //all the tile credit goes to Andrew Reid, 2018
      function getTiles(type, zoom, filter) {
        let tileset = "";
        if (type == "url") {
          tileset = {
            type: "tileset",
            attribution: "",
            source: function (d) {
              return url + "/" + d.z + "/" + d.x + "/" + d.y + "." + format;
            }
          };
        }
        if (type.split("-")[0] == "custom") {
          let dir = type.split("-");
          dir = dir.join("/");
          //console.log(dir);
          tileset = {
            type: "tileset",
            attribution: "",
            source: function (d) {
              if (zoom) {
                d.z = zoom;
              } else {
                d.z = d.z;
              }
              return (
                "https://raw.githubusercontent.com/mbrickmaps/" +
                dir.replace("custom", "") +
                "/" +
                d.z +
                "/" +
                d.x +
                "/" +
                ((1 << d.z) - d.y - 1) +
                ".png"
              );
            }
          };
        }
        if (type == "debug") {
          tileset = {
            source: function (d) {
              return `https://dummyimage.com/256x256/a8a8a8/0011ff.png&text=${
                d.z
              }/${d.x}/${(1 << d.z) - d.y - 1}`;
            }
          };
        }
        return tileset;
      }
      function geoTile(delta) {
        const tau = Math.PI * 2;
        var lim = 85.05113;
        var tileSize = 256;

        var w = width;
        var h = height;

        var pk = w / tau;
        var pc = [0, 0];
        var pr = 0;

        var tk = 2;
        var tx = w / 2;
        var ty = h / 2;

        var p = d3.geoMercator().scale(pk).center(pc);

        var z0 = 0;
        var z1 = 15;
        var extent = function () {
          return { left: -179.99999, top: lim, right: 179.9999, bottom: -lim };
        };
        var wrap = true;

        var tileWidth = 256;
        var tileHeight = 256;
        var xyz = true;

        var source = function (d) {
          return (
            "http://" +
            "abc"[d.y % 3] +
            ".tile.openstreetmap.org/" +
            d.z +
            "/" +
            d.x +
            "/" +
            d.y +
            ".png"
          );
        };
        var a = "Tiles © OpenStreetMap contributors";
        geoTile.xyz = function (_) {
          return arguments.length ? ((xyz = _), geoTile) : xyz;
        };

        function geoTile(_) {
          return p(_);
        }

        geoTile.width = function (_) {
          return arguments.length ? ((w = _), geoTile) : w;
        };
        geoTile.height = function (_) {
          return arguments.length ? ((h = _), geoTile) : h;
        };
        geoTile.size = function (_) {
          if (arguments.length) {
            _ instanceof d3.selection
              ? ((w = _.attr("width")),
                (h = _.attr("height")),
                (tx = w / 2),
                (ty = h / 2))
              : ((w = _[0]), (h = _[1]));
            return geoTile;
          } else return [w, h];
        };
        geoTile.source = function (_) {
          return arguments.length ? ((source = _), geoTile) : source;
        };
        geoTile.projection = function (_) {
          return arguments.length
            ? ((p = _), (pk = _.scale()), (pc = _.center()), geoTile)
            : p;
        };
        geoTile.attribution = function (_) {
          return arguments.length ? ((a = _), geoTile) : a;
        };
        geoTile.wrap = function (_) {
          return arguments.length ? ((wrap = _), geoTile) : wrap;
        };
        geoTile.tileWidth = function (_) {};
        geoTile.tileHeight = function (_) {};

        geoTile.invert = function (_) {
          return p.invert(_);
        };
        geoTile.center = function (_) {
          var rotate = d3.geoRotation(p.rotate());
          if (arguments.length) {
            pc = rotate(_);
            p.center(pc);
            return geoTile;
          } else {
            return rotate.invert(pc);
          }
        };
        geoTile.scale = function (_) {
          return arguments.length ? ((pk = _), p.scale(pk), geoTile) : pk;
        };
        geoTile.rotate = function (_) {
          return arguments.length ? ((pr = _), p.rotate([pr, 0]), geoTile) : pr;
        };
        geoTile.fit = function (_) {
          return arguments.length
            ? (p.fitSize([w, h], _),
              (tx = p.translate()[0]),
              (ty = p.translate()[1]),
              (pk = p.scale()),
              geoTile)
            : "n/a";
        };
        geoTile.fitMargin = function (m, f) {
          return arguments.length > 1
            ? (p.fitExtent(
                [
                  [m, m],
                  [w - m, h - m]
                ],
                f
              ),
              (tx = p.translate()[0]),
              (ty = p.translate()[1]),
              (pk = p.scale()),
              geoTile)
            : "n/a";
        };

        geoTile.zoomScale = function (_) {
          return arguments.length ? ((tk = _), p.scale(pk * tk), geoTile) : tk;
        };
        geoTile.zoomTranslate = function (_) {
          return arguments.length
            ? ((tx = _[0]), (ty = _[1]), p.translate([tx, ty]), geoTile)
            : [tx, ty];
        };
        geoTile.zoomIdentity = function () {
          return d3.zoomIdentity.translate(tx, ty).scale(tk).translate(0, 0);
        };
        geoTile.zoomTransform = function (t) {
          return (
            (tx = t.x),
            (ty = t.y),
            (tk = t.k),
            p.translate([tx, ty]),
            p.scale(pk * tk),
            geoTile
          );
        };

        geoTile.tileDepth = function () {
          var a = [w / 2 - 1, h / 2];
          var b = [w / 2 + 1, h / 2];
          var dx = d3.geoDistance(p.invert(a), p.invert(b));
          var scale = ((20 / dx) * tk * pk) / 200;
          var z = Math.max(Math.log(scale) / Math.LN2 - 8, 2);
          z = Math.min(z, 15) | 0;
          var maxTiles = (w * h) / 256 / 128;

          while (d3quadTiles(p, z).length > maxTiles) {
            z--;
          }

          if (delta) {
            z = z + delta;
          }
          return z;
        };
        geoTile.zoomTranslateExtent = function (_) {
          var e = extent();
          if (arguments.length) {
            e.left = _[0][0];
            e.top = _[0][1];
            e.right = _[1][0];
            e.bottom = _[1][1];
            return geoTile;
          } else {
            var x0 = p([e.left - pr, e.top])[0] - tx;
            var y0 = p([e.left - pr, e.top])[1] - ty;
            var x1 = p([e.right - pr, e.bottom])[0] - tx;
            var y1 = p([e.right - pr, e.bottom])[1] - ty;
            return [
              [x0, y0],
              [x1, y1]
            ];
          }
        };
        geoTile.zoomTranslateConstrain = function () {
          var e = extent();
          e.left = p.invert([0, 0])[0];
          e.top = p.invert([0, 0])[1];
          e.right = p.invert([w, h])[0];
          e.bottom = p.invert([w, h])[1];

          var x0 = p([e.left - pr, e.top])[0] - tx;
          var y0 = p([e.left - pr, e.top])[1] - ty;
          var x1 = p([e.right - pr, e.bottom])[0] - tx;
          var y1 = p([e.right - pr, e.bottom])[1] - ty;
          return [
            [x0, y0],
            [x1, y1]
          ];
        };

        geoTile.tiles = function () {
          var z = geoTile.tileDepth();
          // var e = p.clipExtent();
          var set = d3quadTiles(p, Math.max(z0, Math.min(z, z1)));
          //p.clipExtent(e);

          return set;
        };
        geoTile.tile = function (g) {
          let uid = g.attr("id").split("-")[1];
          let type = g.attr("id").split("-")[2];

          var path = d3.geoPath(p);

          var tile = g.selectAll("tiles").data(geoTile.tiles());

          var enter = tile
            .enter()
            .append("image")
            .attr("class", "tile")
            .attr("id", function (d) {
              return "tile-" + type + "-" + uid + "-" + d.key.join("-");
            })
            .each(function (d) {
              var k = d.key;
              var that = this;
              d.image = new Image();
              d.image.crossOrigin = true;
              var location = { x: k[0], y: k[1], z: k[2] };
              d.image.src = source(location);
              d.image.onload = function () {
                onload(d, that);
              };
            });

          function onload(d, that) {
            var mercatorCanvas = d3
              .create("canvas")
              .attr("width", tileWidth)
              .attr("height", tileHeight);

            var mercatorContext = mercatorCanvas.node().getContext("2d");
            mercatorContext.drawImage(d.image, 0, 0, tileWidth, tileHeight);

            var k = d.key;
            var tilesAcross = 1 << k[2];

            var webMercator = d3
              .geoMercator()
              .scale(tilesAcross / Math.PI / 2)
              .translate([0, 0])
              .center([0, 0]);

            var reprojectedTileBounds = path.bounds(d),
              x0 = reprojectedTileBounds[0][0] | 0,
              y0 = reprojectedTileBounds[0][1] | 0,
              x1 = (reprojectedTileBounds[1][0] + 1) | 0,
              y1 = (reprojectedTileBounds[1][1] + 1) | 0;

            var λ0 = (k[0] / tilesAcross) * 360 - 180,
              λ1 = ((k[0] + 1) / tilesAcross) * 360 - 180,
              φ1 = webMercator.invert([0, k[1] - tilesAcross / 2])[1],
              φ0 = webMercator.invert([0, k[1] + 1 - tilesAcross / 2])[1];

            var newCanvas = d3.create("canvas").node();

            (newCanvas.width = x1 - x0), (newCanvas.height = y1 - y0);
            var newContext = newCanvas.getContext("2d");

            if (newCanvas.width > 0 && newCanvas.height > 0) {
              var sourceData = mercatorContext.getImageData(
                  0,
                  0,
                  tileWidth,
                  tileHeight
                ).data,
                target = newContext.createImageData(
                  newCanvas.width,
                  newCanvas.height
                ),
                targetData = target.data;

              for (var y = y0, i = -1; y < y1; ++y) {
                for (var x = x0; x < x1; ++x) {
                  var pt = p.invert([x, y]),
                    λ = pt[0],
                    φ = pt[1];

                  if (λ > λ1 || λ < λ0 || φ > φ1 || φ < φ0) {
                    i += 4;
                    targetData[i] = 0;
                    continue;
                  }
                  var top =
                    ((((tilesAcross + webMercator([0, φ])[1]) * tileHeight) |
                      0) %
                      256 |
                      0) *
                    tileWidth;
                  var q =
                    (((((λ - λ0) / (λ1 - λ0)) * tileWidth) | 0) + top) * 4;

                  let r = sourceData[q];
                  let g = sourceData[++q];
                  let b = sourceData[++q];
                  let a = 255;

                  targetData[++i] = r;
                  targetData[++i] = g;
                  targetData[++i] = b;
                  targetData[++i] = a;
                }
              }

              if (target) newContext.putImageData(target, 0, 0);
            }

            d3.select("#" + d3.select(that).attr("id"))
              .attr("xlink:href", newCanvas.toDataURL())
              .attr("x", x0)
              .attr("width", Math.ceil(newCanvas.width) + 1)
              .attr("height", Math.ceil(newCanvas.height) + 1)
              .attr("y", y0);
          }
        };

        geoTile.tileSet = function (_) {
          if (arguments.length) {
            a = _.attribution ? _.attribution : "Unknown";
            source = _.source
              ? _.source
              : (console.log("no source provided, using osm"),
                (a = "Tiles © OpenStreetMap contributors"),
                function (d) {
                  return (
                    "http://" +
                    "abc"[d.y % 3] +
                    ".tile.openstreetmap.org/" +
                    d.z +
                    "/" +
                    d.x +
                    "/" +
                    d.y +
                    ".png"
                  );
                });
            lim = _.limit ? _.limit : 85.05113;
            tileSize = _.tileSize ? _.tileSize : 256;
            z0 = _.minDepth ? _.minDepth : 1;
            z1 = _.maxDepth ? _.maxDepth : 13;
            wrap = _.wrap ? _.wrap : false;
            xyz = _.xyz ? _.xyz : true;
          }
          return geoTile;
        };
        return geoTile;
      }
      function d3quadTiles(projection, zoom) {
        var tiles = [],
          width = 1 << (zoom = Math.max(0, zoom)),
          step = Math.max(0.2, Math.min(1, zoom * 0.01)),
          invisible,
          precision = projection.precision(),
          stream = projection.precision(960).stream({
            point: function () {
              invisible = false;
            },
            lineStart: noop,
            lineEnd: noop,
            polygonStart: noop,
            polygonEnd: noop
          });

        visit(-180, -180, 180, 180);

        projection.precision(precision);

        return tiles;

        function visit(x1, y1, x2, y2) {
          var w = x2 - x1,
            m1 = mercatorφ(y1),
            m2 = mercatorφ(y2),
            δ = step * w;
          invisible = true;
          stream.polygonStart(), stream.lineStart();
          for (var x = x1; x < x2 + δ / 2 && invisible; x += δ)
            stream.point(x, m1);
          for (var y = m1; (y += δ) < m2 && invisible; ) stream.point(x2, y);
          for (var x = x2; x > x1 - δ / 2 && invisible; x -= δ)
            stream.point(x, m2);
          for (var y = m2; (y -= δ) > m1 && invisible; ) stream.point(x1, y);
          if (invisible) stream.point(x1, m1);
          stream.lineEnd(), stream.polygonEnd();
          if (w <= 360 / width) {
            if (!invisible) {
              tiles.push({
                type: "Polygon",
                coordinates: [
                  d3
                    .range(x1, x2 + δ / 2, δ)
                    .map(function (x) {
                      return [x, y1];
                    })
                    .concat([[x2, 0.5 * (y1 + y2)]])
                    .concat(
                      d3.range(x2, x1 - δ / 2, -δ).map(function (x) {
                        return [x, y2];
                      })
                    )
                    .concat([[x1, 0.5 * (y1 + y2)]])
                    .concat([[x1, y1]])
                    .map(function (d) {
                      return [d[0], mercatorφ(d[1])];
                    })
                ],
                key: [
                  (((180 + x1) / 360) * width) | 0,
                  (((180 + y1) / 360) * width) | 0,
                  zoom
                ],
                centroid: [0.5 * (x1 + x2), 0.5 * (m1 + m2)]
              });
            }
          } else if (!invisible) {
            var x = 0.5 * (x1 + x2),
              y = 0.5 * (y1 + y2);
            visit(x1, y1, x, y);
            visit(x, y1, x2, y);
            visit(x1, y, x, y2);
            visit(x, y, x2, y2);
          }
        }
      }
      function mercatorφ(y) {
        return (Math.atan(Math.exp((-y * Math.PI) / 180)) * 360) / Math.PI - 90;
      }
      function noop() {}
    }
    if (this.layer.grids.show) {
      if (this.layer.grids.data.length > 0) {
        console.log("show grid");
        let grids = this.layer.grids;
        addGrid(grids, width / grids.size, grids.data);
      }
    }

    function addQtree(grids, data) {
      let pointsRaw = data.map((d) => projection(d.geometry.coordinates));

      let quadtree = d3
        .quadtree()
        .extent([
          [-1, -1],
          [width + 1, height + 1]
        ])
        .addAll(pointsRaw);

      function filterByAttribute(attribute, value) {
        const filteredPoints = [];
        quadtree.visit((node, x0, y0, x1, y1) => {
          if (node.length) {
            // if it's an internal node
            const children = node.slice(0, 4); // get the child nodes
            for (const child of children) {
              if (child) {
                // if the child exists
                child.forEach((d) => {
                  if (d[attribute] === value) {
                    // check if the attribute matches the desired value
                    filteredPoints.push(d); // add the point to the filtered array
                  }
                });
              }
            }
          }
        });
        return filteredPoints;
      }

      if (grids.type == "byAttribute") {
        let groupedData = d3.group(
          data,
          (d) => d.properties.data[grids.method.groupBy]
        );
        let attributeValues = Array.from(groupedData.keys());
        let filteredData = attributeValues.map((value) => {
          return {
            group: value,
            geom: groupedData.get(value)
          };
        });
        filteredData.total = filteredData
          .map((d) => d.geom.length)
          .reduce((sum, a) => sum + a, 0);
      }

      function search(quadtree, xmin, ymin, xmax, ymax) {
        const results = [];
        quadtree.visit((node, x1, y1, x2, y2) => {
          if (!node.length) {
            do {
              let d = node.data;
              if (d[0] >= xmin && d[0] < xmax && d[1] >= ymin && d[1] < ymax) {
                results.push(d);
              }
            } while ((node = node.next));
          }
          return x1 >= xmax || y1 >= ymax || x2 < xmin || y2 < ymin;
        });
        return results;
      }

      let clusterPoints = [];
      let clusterRange = width / grids.size;

      for (let x = 0; x <= width; x += clusterRange) {
        for (let y = 0; y <= height; y += clusterRange) {
          let searched = search(
            quadtree,
            x,
            y,
            x + clusterRange,
            y + clusterRange
          );
          let centerPoint = searched.reduce(
            function (prev, current) {
              return [prev[0] + current[0], prev[1] + current[1]];
            },
            [0, 0]
          );

          centerPoint[0] = centerPoint[0] / searched.length;
          centerPoint[1] = centerPoint[1] / searched.length;
          centerPoint.push(searched);
          if (centerPoint[0] && centerPoint[1]) {
            if (grids.method.type == "raw") {
              clusterPoints.push(
                turf.point(
                  projection.invert([centerPoint[0], centerPoint[1]]),
                  {
                    count: searched.length
                  }
                )
              );
            } else {
            }
          } else {
          }
        }
      }

      let pScale = d3
        .scaleSqrt()
        .domain([
          d3.min(clusterPoints, (d) => d.properties.count),
          d3.max(clusterPoints, (d) => d.properties.count)
        ])
        .rangeRound([grids.minSize, grids.maxSize]);
      if (grids.square.show == false) {
        ggrid.remove();
      }
      if (grids.qtree.show == true) {
        function materialize(quadtree) {
          const rects = [];
        }
      }
      new Layer({
        geometry: clusterPoints,
        group: glayer,
        path: path,
        type: grids.type,
        shape: grids.shape,
        style: grids.style,
        scale: pScale //grids.scale
      }).add;
    }

    function addGrid(grids, units, data) {
      if (grids.type == "qtree" || grids.type == "byAttribute") {
        var clusterPoints = [];
        var clusterRange = units;
        for (var x = 0; x <= width; x += clusterRange) {
          for (var y = 0; y <= height; y += clusterRange) {
            ggrid
              .append("rect")
              .attr("x", x)
              .attr("y", y)
              .attr("width", clusterRange)
              .attr("height", clusterRange)
              .attr("class", "ggrid")
              .attr("fill", "red")
              .attr("fill-opacity", 0.2)
              .attr("stroke", "red");
          }
        }

        addQtree(grids, data);
      }
      if (grids.type == "geogrid") {
        addGeoGrid(data, grids);
      }
    }

    function addGeoGrid(data, grids) {
      let points = data.map((d) =>
        turf.point(d.coordinates, { count: d.properties.number })
      );
      let mPoints = turf.featureCollection(points);
      let vPoints = turf.voronoi(mPoints, {
        bbox: turf.bboxPolygon(turf.bbox(mPoints)).bbox
      });
      let bbox = turf.bboxPolygon(turf.bbox(mPoints)).bbox;
      let sPoints = turf.squareGrid(
        [+bbox[0] - 1, +bbox[1] - 1, +bbox[2] + 1, +bbox[3] + 1],
        grids.size,
        {
          units: "degrees"
        }
      );

      let col = turf.collect(sPoints, mPoints, "count", "count");

      let colorScale = d3.scaleSqrt().domain([1, 83]).range(["yellow", "red"]);
      new Layer({
        geometry: col.features,
        group: glayer,
        path: path,
        style: {
          stroke: "none",
          "stroke-dasharray": null,
          "stroke-dashoffset": null,
          "stroke-linecap": null,
          "stroke-linejoin": null,
          "stroke-miterlimit": null,
          "stroke-opacity": null,
          "stroke-width": null,
          fill: function (feature) {
            if (feature.properties.count.length > 0) {
              if (feature.properties.count) {
                let c = feature.properties.count.reduce(function (a, b) {
                  return a + b;
                });
                console.log(c, colorScale(c));
                return colorScale(c);
              }
            } else {
              return "none";
            }
          },
          "fill-opacity": 1,
          opacity: null
        }
      }).add;
    }

    if (this.layer.points.show) {
      if (this.layer.points.show) {
        if (this.layer.points.data.length > 0) {
          let groups = new Set(this.layer.points.data.map((d) => d.type));
          createAnnotationGroups(groups);
          addPoints(this.layer.points.data);
        }
      }

      function createAnnotationGroups(groups) {
        for (let g of groups) {
          gannotation.append("g").attr("id", "type-" + uid + "-" + g);
        }
      }

      function addPoints(data) {
        if (data[0].name !== "") {
          var z = "";
          var labelClass = "v-text-contextual-city";
          var anchorPoint = "start";
          let unit = 0;
          var dx = 0;
          var dy = 0;
          for (z in data) {
            if (data[z].x && data[z].y) {
              data[z].lng = data[z].x;
              data[z].lat = data[z].y;
            }
            if (data[z].latlng) {
              data[z].lng = data[z].latlng.split(",")[0].trim();
              data[z].lat = data[z].latlng.split(",")[1].trim();
            }

            if (data[z].name.length > 0) {
              unit = 4;
              let symbol = "";
              let shape = data[z].shape ? data[z].shape : "circle";
              let adjustLabel = data[z].dir.indexOf("-") > -1 ? true : false;
              let dir = data[z].dir.trim().split("-")[0];
              let type = data[z].type.trim();

              if (["city1", "capital", "Admin-0 capital"].indexOf(type) > -1) {
                labelClass = "v-text-capital-city";
                symbol = "#iconStar";
              }
              if (["city2", "focal", "Admin-1 capital"].indexOf(type) > -1) {
                labelClass = "v-text-focal-city";
                symbol = "#iconCity";
              }
              if (["city3", "context", "Populated place"].indexOf(type) > -1) {
                labelClass = "v-text-contextual-city";
                symbol = "#iconCity";
              }
              if (["custom"].indexOf(type) > -1) {
                shape = data[z].shape ? data[z].shape : "circle";
                labelClass = data[z].group;
              } else {
                labelClass = "v-text-contextual-city";
              }

              if (adjustLabel) {
                unit = data[z].dir.split("-")[1];
              }
              if (["N"].indexOf(dir) > -1) {
                anchorPoint = "middle";
                dx = 0;
                dy = -unit * 2;
              }
              if (["C"].indexOf(dir) > -1) {
                anchorPoint = "middle";
                dx = 0;
                dy = 0;
              }
              if (["NE"].indexOf(dir) > -1) {
                anchorPoint = "start";
                dx = unit + 5;
                dy = -unit;
              }
              if (["E"].indexOf(dir) > -1) {
                anchorPoint = "start";
                dx = unit + 5;
                dy = 4;
              }
              if (["SE"].indexOf(dir) > -1) {
                anchorPoint = "start";
                dx = unit + 5;
                dy = unit * 3;
              }
              if (["S"].indexOf(dir) > -1) {
                anchorPoint = "middle";
                dx = 0;
                dy = unit * 3 + 3;
              }
              if (["SW"].indexOf(dir) > -1) {
                anchorPoint = "end";
                dx = -unit - 5;
                dy = unit * 3;
              }
              if (["W"].indexOf(dir) > -1) {
                anchorPoint = "end";
                dx = -unit - 5;
                dy = 4;
              }
              if (["NW"].indexOf(dir) > -1) {
                anchorPoint = "end";
                dx = -unit - 5;
                dy = -unit;
              }

              let groupText = gannotation.select("#type-" + uid + "-" + type);

              if (symbol == "") {
                if (shape == "circle") {
                  groupText
                    .append("g")
                    .append("circle")
                    .attr("r", data[z].size ? data[z].size : 5)
                    .attr("fill", data[z].color ? data[z].color : "#412c26")
                    .attr("stroke", data[z].stroke ? data[z].stroke : "none")
                    .attr(
                      "stroke-width",
                      data[z]["stroke-width"] ? data[z]["stroke-width"] : 0
                    )
                    .attr("opacity", data[z].opacity ? data[z].opacity : 1)
                    .attr(
                      "cx",
                      (function () {
                        return projection([data[z].lat, data[z].lng])[0];
                      })()
                    )
                    .attr(
                      "cy",
                      (function () {
                        return projection([data[z].lat, data[z].lng])[1];
                      })()
                    );
                }
                if (shape == "square") {
                  let customIcon = d3
                    .symbol()
                    .type(d3.symbolSquare)
                    .size(data[z].size ? data[z].size : 5)();
                  groupText
                    .append("path")
                    .attr("d", customIcon)
                    .attr("fill", data[z].color ? data[z].color : "#412c26")
                    .attr("stroke", data[z].stroke ? data[z].stroke : "none")
                    .attr(
                      "stroke-width",
                      data[z]["stroke-width"] ? data[z]["stroke-width"] : 0
                    )
                    .attr("opacity", data[z].opacity ? data[z].opacity : 1)
                    .attr(
                      "transform",
                      `translate(${projection([data[z].lat, data[z].lng])[0]},${
                        projection([data[z].lat, data[z].lng])[1]
                      })`
                    );
                }
                if (shape == "triangle") {
                  let customIcon = d3
                    .symbol()
                    .type(d3.symbolTriangle)
                    .size(data[z].size ? data[z].size : 5)();
                  groupText
                    .append("path")
                    .attr("d", customIcon)
                    .attr("fill", data[z].color ? data[z].color : "#412c26")
                    .attr("stroke", data[z].stroke ? data[z].stroke : "none")
                    .attr(
                      "stroke-width",
                      data[z]["stroke-width"] ? data[z]["stroke-width"] : 0
                    )
                    .attr("opacity", data[z].opacity ? data[z].opacity : 1)
                    .attr(
                      "transform",
                      `translate(${projection([data[z].lat, data[z].lng])[0]},${
                        projection([data[z].lat, data[z].lng])[1]
                      })`
                    )
                    .attr("dx", data[z].dx ? data[z].dx : 0)
                    .attr("dy", data[z].dy ? data[z].dy : 0);
                }
                if (shape == "cross") {
                  let customIcon = d3
                    .symbol()
                    .type(d3.symbolCross)
                    .size(data[z].size ? data[z].size : 5)();
                  groupText
                    .append("path")
                    .attr("d", customIcon)
                    .attr("fill", data[z].color ? data[z].color : "#412c26")
                    .attr("stroke", data[z].stroke ? data[z].stroke : "none")
                    .attr(
                      "stroke-width",
                      data[z]["stroke-width"] ? data[z]["stroke-width"] : 0
                    )
                    .attr("opacity", data[z].opacity ? data[z].opacity : 1)
                    .attr(
                      "transform",
                      `translate(${projection([data[z].lat, data[z].lng])[0]},${
                        projection([data[z].lat, data[z].lng])[1]
                      })`
                    )
                    .attr("dx", data[z].dx ? data[z].dx : 0)
                    .attr("dy", data[z].dy ? data[z].dy : 0);
                }
                if (shape == "diamond") {
                  let customIcon = d3
                    .symbol()
                    .type(d3.symbolDiamond)
                    .size(data[z].size ? data[z].size : 5)();
                  groupText
                    .append("path")
                    .attr("d", customIcon)
                    .attr("fill", data[z].color ? data[z].color : "#412c26")
                    .attr("stroke", data[z].stroke ? data[z].stroke : "none")
                    .attr(
                      "stroke-width",
                      data[z]["stroke-width"] ? data[z]["stroke-width"] : 0
                    )
                    .attr("opacity", data[z].opacity ? data[z].opacity : 1)
                    .attr(
                      "transform",
                      `translate(${projection([data[z].lat, data[z].lng])[0]},${
                        projection([data[z].lat, data[z].lng])[1]
                      })`
                    )
                    .attr("dx", data[z].dx ? data[z].dx : 0)
                    .attr("dy", data[z].dy ? data[z].dy : 0);
                }
                if (shape == "star") {
                  let customIcon = d3
                    .symbol()
                    .type(d3.symbolStar)
                    .size(data[z].size ? data[z].size : 5)();
                  groupText
                    .append("path")
                    .attr("d", customIcon)
                    .attr("fill", data[z].color ? data[z].color : "#412c26")
                    .attr("stroke", data[z].stroke ? data[z].stroke : "none")
                    .attr(
                      "stroke-width",
                      data[z]["stroke-width"] ? data[z]["stroke-width"] : 0
                    )
                    .attr("opacity", data[z].opacity ? data[z].opacity : 1)
                    .attr(
                      "transform",
                      `translate(${projection([data[z].lat, data[z].lng])[0]},${
                        projection([data[z].lat, data[z].lng])[1]
                      })`
                    )
                    .attr("dx", data[z].dx ? data[z].dx : 0)
                    .attr("dy", data[z].dy ? data[z].dy : 0);
                }
                if (shape == "wye") {
                  let customIcon = d3
                    .symbol()
                    .type(d3.symbolWye)
                    .size(data[z].size ? data[z].size : 5)();
                  groupText
                    .append("path")
                    .attr("d", customIcon)
                    .attr("fill", data[z].color ? data[z].color : "#412c26")
                    .attr("stroke", data[z].stroke ? data[z].stroke : "none")
                    .attr(
                      "stroke-width",
                      data[z]["stroke-width"] ? data[z]["stroke-width"] : 0
                    )
                    .attr("opacity", data[z].opacity ? data[z].opacity : 1)
                    .attr(
                      "transform",
                      `translate(${projection([data[z].lat, data[z].lng])[0]},${
                        projection([data[z].lat, data[z].lng])[1]
                      })`
                    )
                    .attr("dx", data[z].dx ? data[z].dx : 0)
                    .attr("dy", data[z].dy ? data[z].dy : 0);
                }
              } else {
                groupText
                  .append("use")
                  .attr("href", symbol)
                  .attr(
                    "transform",
                    `translate(${projection([data[z].lat, data[z].lng])[0]},${
                      projection([data[z].lat, data[z].lng])[1]
                    })`
                  )
                  .attr("dx", data[z].dx ? data[z].dx : 0)
                  .attr("dy", data[z].dy ? data[z].dy : 0);
              }

              if (["C"].indexOf(dir) > -1) {
                groupText
                  .append("text")
                  .attr("id", `${data[z].name}`.replace(" ", "_")) //should be replace all
                  .attr("class", labelClass)
                  .attr("text-anchor", anchorPoint)
                  .attr("alignment-baseline", "middle")
                  .text(data[z].name)
                  .attr("transform", `translate(${dx}, ${dy})`)
                  .attr(
                    "x",
                    (function () {
                      return projection([data[z].lat, data[z].lng])[0];
                    })()
                  )
                  .attr(
                    "y",
                    (function () {
                      return projection([data[z].lat, data[z].lng])[1];
                    })()
                  );
              } else {
                groupText
                  .append("text")
                  .attr("id", `${data[z].name}`.replace(" ", "_")) //should be replace all
                  .attr("class", labelClass)
                  .attr("text-anchor", anchorPoint)
                  .text(data[z].name)
                  .attr("transform", `translate(${dx}, ${dy})`)
                  .attr(
                    "x",
                    (function () {
                      return projection([data[z].lat, data[z].lng])[0];
                    })()
                  )
                  .attr(
                    "y",
                    (function () {
                      return projection([data[z].lat, data[z].lng])[1];
                    })()
                  );
              }
            }
          }
        } else {
        }
      }
    }

    return graphic.node();
  }
}
return {Mapa};
}});

define({id: "d071e268", inputs: ["turf"], outputs: ["getDistance"], body: (turf) => {
function getDistance(p1, p2, unit) {
  var point1 = {
    type: "Feature",
    properties: {},
    geometry: {
      type: "Point",
      coordinates: p1.split(",")
    }
  };
  var point2 = {
    type: "Feature",
    properties: {},
    geometry: {
      type: "Point",
      coordinates: p2.split(",")
    }
  };
  var units = unit;

  var points = {
    type: "FeatureCollection",
    features: [point1, point2]
  };

  //=points

  var distance = turf.distance(point1, point2, units);
  return distance;
}
return {getDistance};
}});

define({id: "20759fbd", inputs: ["getCountryLabels","isoQ"], outputs: ["MiddleEast_Labels"], body: (getCountryLabels,isoQ) => {
const MiddleEast_Labels = [
  "MA",
  "LY",
  "TN",
  "Algeria",
  "Egypt",
  "IL",
  "IS",
  "IR",
  "IQ",
  "Syria",
  "Lebanon",
  "JO",
  "Turkey",
  "Saudi Arabia"
].map((d) => {
  return getCountryLabels([isoQ(d)[0][1]])[0];
})
return {MiddleEast_Labels};
}});

define({id: "2d6cb8cd", inputs: ["turf"], outputs: ["getmyCentroid"], body: (turf) => {
function getmyCentroid(myfeatures, label, type, color) {
  let point = [];
  var x;

  function getCentroid(arr) {
    var polygon = turf.polygon([arr]);
    var center = turf.centerOfMass(polygon);
    return {
      lng: center.geometry.coordinates[0],
      lat: center.geometry.coordinates[1]
    };
  }

  for (x in myfeatures) {
    let mainBody = {
      type: "country",
      size: -1,
      shape: "circle",
      color: "#412c26",
      dir: "C"
    };
    var lengths = myfeatures[x].geometry.coordinates.map(function (a) {
      return a[0].length;
    });

    if (myfeatures[x].geometry.type == "MultiPolygon") {
      mainBody["name"] = myfeatures[x].properties[label];
      mainBody["lat"] = getCentroid(
        myfeatures[x].geometry.coordinates[
          lengths.indexOf(Math.max.apply(Math, lengths))
        ][0]
      ).lat;
      mainBody["lng"] = getCentroid(
        myfeatures[x].geometry.coordinates[
          lengths.indexOf(Math.max.apply(Math, lengths))
        ][0]
      ).lng;
      mainBody["latlng"] =
        getCentroid(
          myfeatures[x].geometry.coordinates[
            lengths.indexOf(Math.max.apply(Math, lengths))
          ][0]
        ).lat +
        ", " +
        getCentroid(
          myfeatures[x].geometry.coordinates[
            lengths.indexOf(Math.max.apply(Math, lengths))
          ][0]
        ).lng;
    } else {
      mainBody["name"] = myfeatures[x].properties[label];
      mainBody["lat"] = getCentroid(
        myfeatures[x].geometry.coordinates[
          lengths.indexOf(Math.max.apply(Math, lengths))
        ]
      ).lat;
      mainBody["lng"] = getCentroid(
        myfeatures[x].geometry.coordinates[
          lengths.indexOf(Math.max.apply(Math, lengths))
        ]
      ).lng;
      mainBody["latlng"] =
        getCentroid(
          myfeatures[x].geometry.coordinates[
            lengths.indexOf(Math.max.apply(Math, lengths))
          ]
        ).lat +
        ", " +
        getCentroid(
          myfeatures[x].geometry.coordinates[
            lengths.indexOf(Math.max.apply(Math, lengths))
          ]
        ).lng;
    }
    point.push(mainBody);
  }
  return point;
}
return {getmyCentroid};
}});

define({id: "513f582c", inputs: ["turf"], outputs: ["getCentroid"], body: (turf) => {
function getCentroid(myfeatures, label, uid, color) {
  let point = [];
  var x;

  function getCentroid(arr) {
    var polygon = turf.polygon([arr]);
    var center = turf.centerOfMass(polygon);
    return {
      lng: center.geometry.coordinates[0],
      lat: center.geometry.coordinates[1]
    };
  }

  for (x in myfeatures) {
    let mainBody = {};
    var lengths = myfeatures[x].geometry.coordinates.map(function (a) {
      return a[0].length;
    });

    if (myfeatures[x].geometry.type == "MultiPolygon") {
      mainBody["uid"] = myfeatures[x].properties[uid];
      mainBody["label"] = myfeatures[x].properties[label];
      mainBody["lat"] = getCentroid(
        myfeatures[x].geometry.coordinates[
          lengths.indexOf(Math.max.apply(Math, lengths))
        ][0]
      ).lat;
      mainBody["lng"] = getCentroid(
        myfeatures[x].geometry.coordinates[
          lengths.indexOf(Math.max.apply(Math, lengths))
        ][0]
      ).lng;
      mainBody["color"] = getCentroid(
        myfeatures[x].geometry.coordinates[
          lengths.indexOf(Math.max.apply(Math, lengths))
        ][0]
      ).color;
    } else {
      mainBody["uid"] = myfeatures[x].properties[uid];
      mainBody["label"] = myfeatures[x].properties[label];
      mainBody["lat"] = getCentroid(
        myfeatures[x].geometry.coordinates[
          lengths.indexOf(Math.max.apply(Math, lengths))
        ]
      ).lat;
      mainBody["lng"] = getCentroid(
        myfeatures[x].geometry.coordinates[
          lengths.indexOf(Math.max.apply(Math, lengths))
        ]
      ).lng;
      mainBody["color"] = getCentroid(
        myfeatures[x].geometry.coordinates[
          lengths.indexOf(Math.max.apply(Math, lengths))
        ]
      ).color;
    }
    point.push(mainBody);
  }
  return point;
}
return {getCentroid};
}});

define({id: "353fc809", inputs: ["countries","display"], body: async (countries,display) => {
display(await(
countries
))
}});

define({id: "869287f4", inputs: ["places"], outputs: ["getCities"], body: (places) => {
function getCities(iso, num) {
  return places
    .filter(function (d) {
      if (d.properties.ISO_A2 == iso) {
        return d;
      }
    })
    .sort((a, b) => b.properties.POP2020 - a.properties.POP2020)
    .slice(0, num + 1)
    .map(function (d) {
      if (d.properties.ADM0CAP == "1") {
        return {
          name: d.properties.NAME,
          latlng: d.properties.LATITUDE + ", " + d.properties.LONGITUDE,
          shape: "star",
          type: "city",
          size: "64",
          dir: "NE"
        };
      } else {
        return {
          name: d.properties.NAME,
          latlng: d.properties.LATITUDE + ", " + d.properties.LONGITUDE,
          shape: "circle",
          type: "city",
          size: "4",
          dir: "NE"
        };
      }
    });
}
return {getCities};
}});

define({id: "fbf42667", outputs: ["countryData"], body: () => {
const countryData = [
  { name: "Afghanistan", ISO2: "AF", ISO3: "AFG" },
  { name: "Albania", ISO2: "AL", ISO3: "ALB" },
  { name: "Algeria", ISO2: "DZ", ISO3: "DZA" },
  { name: "Andorra", ISO2: "AD", ISO3: "AND" },
  { name: "Angola", ISO2: "AO", ISO3: "AGO" },
  { name: "Antigua and Barbuda", ISO2: "AG", ISO3: "ATG" },
  { name: "Argentina", ISO2: "AR", ISO3: "ARG" },
  { name: "Armenia", ISO2: "AM", ISO3: "ARM" },
  { name: "Australia", ISO2: "AU", ISO3: "AUS" },
  { name: "Austria", ISO2: "AT", ISO3: "AUT" },
  { name: "Azerbaijan", ISO2: "AZ", ISO3: "AZE" },
  { name: "Bahamas", ISO2: "BS", ISO3: "BHS" },
  { name: "Bahrain", ISO2: "BH", ISO3: "BHR" },
  { name: "Bangladesh", ISO2: "BD", ISO3: "BGD" },
  { name: "Barbados", ISO2: "BB", ISO3: "BRB" },
  { name: "Belarus", ISO2: "BY", ISO3: "BLR" },
  { name: "Belgium", ISO2: "BE", ISO3: "BEL" },
  { name: "Belize", ISO2: "BZ", ISO3: "BLZ" },
  { name: "Benin", ISO2: "BJ", ISO3: "BEN" },
  { name: "Bhutan", ISO2: "BT", ISO3: "BTN" },
  { name: "Bolivia", ISO2: "BO", ISO3: "BOL" },
  { name: "Bosnia and Herzegovina", ISO2: "BA", ISO3: "BIH" },
  { name: "Botswana", ISO2: "BW", ISO3: "BWA" },
  { name: "Brazil", ISO2: "BR", ISO3: "BRA" },
  { name: "Brunei", ISO2: "BN", ISO3: "BRN" },
  { name: "Bulgaria", ISO2: "BG", ISO3: "BGR" },
  { name: "Burkina Faso", ISO2: "BF", ISO3: "BFA" },
  { name: "Burundi", ISO2: "BI", ISO3: "BDI" },
  { name: "Cabo Verde", ISO2: "CV", ISO3: "CPV" },
  { name: "Cape Verde", ISO2: "CV", ISO3: "CPV" },
  { name: "Cambodia", ISO2: "KH", ISO3: "KHM" },
  { name: "Cameroon", ISO2: "CM", ISO3: "CMR" },
  { name: "Canada", ISO2: "CA", ISO3: "CAN" },
  { name: "Central African Republic", ISO2: "CF", ISO3: "CAF" },
  { name: "Chad", ISO2: "TD", ISO3: "TCD" },
  { name: "Chile", ISO2: "CL", ISO3: "CHL" },
  { name: "China", ISO2: "CN", ISO3: "CHN" },
  { name: "Côte d'Ivoire", ISO2: "CI", ISO3: "CIV" },
  { name: "Ivory Coast", ISO2: "CI", ISO3: "CIV" },
  { name: "Colombia", ISO2: "CO", ISO3: "COL" },
  { name: "Comoros", ISO2: "KM", ISO3: "COM" },
  { name: "Congo", ISO2: "CG", ISO3: "COG" },
  { name: "Costa Rica", ISO2: "CR", ISO3: "CRI" },
  { name: "Croatia", ISO2: "HR", ISO3: "HRV" },
  { name: "Cuba", ISO2: "CU", ISO3: "CUB" },
  { name: "Cyprus", ISO2: "CY", ISO3: "CYP" },
  { name: "Czechia", ISO2: "CZ", ISO3: "CZE" },
  { name: "Czech Republic", ISO2: "CZ", ISO3: "CZE" },
  { name: "Democratic Republic of the Congo", ISO2: "CD", ISO3: "COD" },
  { name: "Republic of the Congo", ISO2: "CD", ISO3: "COD" },
  { name: "Democratic Republic of Congo", ISO2: "CD", ISO3: "COD" },
  { name: "Denmark", ISO2: "DK", ISO3: "DNK" },
  { name: "Djibouti", ISO2: "DJ", ISO3: "DJI" },
  { name: "Dominica", ISO2: "DM", ISO3: "DMA" },
  { name: "Dominican Republic", ISO2: "DO", ISO3: "DOM" },
  { name: "Ecuador", ISO2: "EC", ISO3: "ECU" },
  { name: "Egypt", ISO2: "EG", ISO3: "EGY" },
  { name: "El Salvador", ISO2: "SV", ISO3: "SLV" },
  { name: "Equatorial Guinea", ISO2: "GQ", ISO3: "GNQ" },
  { name: "Eritrea", ISO2: "ER", ISO3: "ERI" },
  { name: "Estonia", ISO2: "EE", ISO3: "EST" },
  { name: "Eswatini", ISO2: "SZ", ISO3: "SWZ" },
  { name: "Ethiopia", ISO2: "ET", ISO3: "ETH" },
  { name: "Fiji", ISO2: "FJ", ISO3: "FJI" },
  { name: "Finland", ISO2: "FI", ISO3: "FIN" },
  { name: "France", ISO2: "FR", ISO3: "FRA" },
  { name: "Gabon", ISO2: "GA", ISO3: "GAB" },
  { name: "Gambia", ISO2: "GM", ISO3: "GMB" },
  { name: "Georgia", ISO2: "GE", ISO3: "GEO" },
  { name: "Germany", ISO2: "DE", ISO3: "DEU" },
  { name: "Ghana", ISO2: "GH", ISO3: "GHA" },
  { name: "Greece", ISO2: "GR", ISO3: "GRC" },
  { name: "Grenada", ISO2: "GD", ISO3: "GRD" },
  { name: "Greenland", ISO2: "GL", ISO3: "GRL" },
  { name: "Guatemala", ISO2: "GT", ISO3: "GTM" },
  { name: "Guinea", ISO2: "GN", ISO3: "GIN" },
  { name: "Guinea-Bissau", ISO2: "GW", ISO3: "GNB" },
  { name: "Guinea Bissau", ISO2: "GW", ISO3: "GNB" },
  { name: "Guyana", ISO2: "GY", ISO3: "GUY" },
  { name: "Haiti", ISO2: "HT", ISO3: "HTI" },
  { name: "Honduras", ISO2: "HN", ISO3: "HND" },
  { name: "Hungary", ISO2: "HU", ISO3: "HUN" },
  { name: "Iceland", ISO2: "IS", ISO3: "ISL" },
  { name: "India", ISO2: "IN", ISO3: "IND" },
  { name: "Indonesia", ISO2: "ID", ISO3: "IDN" },
  { name: "Iran", ISO2: "IR", ISO3: "IRN" },
  { name: "Iraq", ISO2: "IQ", ISO3: "IRQ" },
  { name: "Ireland", ISO2: "IE", ISO3: "IRL" },
  { name: "Israel", ISO2: "IL", ISO3: "ISR" },
  { name: "Italy", ISO2: "IT", ISO3: "ITA" },
  { name: "Jamaica", ISO2: "JM", ISO3: "JAM" },
  { name: "Japan", ISO2: "JP", ISO3: "JPN" },
  { name: "Jordan", ISO2: "JO", ISO3: "JOR" },
  { name: "Kazakhstan", ISO2: "KZ", ISO3: "KAZ" },
  { name: "Kenya", ISO2: "KE", ISO3: "KEN" },
  { name: "Kiribati", ISO2: "KI", ISO3: "KIR" },
  { name: "Kuwait", ISO2: "KW", ISO3: "KWT" },
  { name: "Kyrgyzstan", ISO2: "KG", ISO3: "KGZ" },
  { name: "Laos", ISO2: "LA", ISO3: "LAO" },
  { name: "Latvia", ISO2: "LV", ISO3: "LVA" },
  { name: "Lebanon", ISO2: "LB", ISO3: "LBN" },
  { name: "Lesotho", ISO2: "LS", ISO3: "LSO" },
  { name: "Liberia", ISO2: "LR", ISO3: "LBR" },
  { name: "Libya", ISO2: "LY", ISO3: "LBY" },
  { name: "Liechtenstein", ISO2: "LI", ISO3: "LIE" },
  { name: "Lithuania", ISO2: "LT", ISO3: "LTU" },
  { name: "Luxembourg", ISO2: "LU", ISO3: "LUX" },
  { name: "Madagascar", ISO2: "MG", ISO3: "MDG" },
  { name: "Malawi", ISO2: "MW", ISO3: "MWI" },
  { name: "Malaysia", ISO2: "MY", ISO3: "MYS" },
  { name: "Maldives", ISO2: "MV", ISO3: "MDV" },
  { name: "Mali", ISO2: "ML", ISO3: "MLI" },
  { name: "Malta", ISO2: "MT", ISO3: "MLT" },
  { name: "Marshall Islands", ISO2: "MH", ISO3: "MHL" },
  { name: "Mauritania", ISO2: "MR", ISO3: "MRT" },
  { name: "Mauritius", ISO2: "MU", ISO3: "MUS" },
  { name: "Mexico", ISO2: "MX", ISO3: "MEX" },
  { name: "Micronesia", ISO2: "FM", ISO3: "FSM" },
  { name: "Moldova", ISO2: "MD", ISO3: "MDA" },
  { name: "Monaco", ISO2: "MC", ISO3: "MCO" },
  { name: "Mongolia", ISO2: "MN", ISO3: "MNG" },
  { name: "Montenegro", ISO2: "ME", ISO3: "MNE" },
  { name: "Morocco", ISO2: "MA", ISO3: "MAR" },
  { name: "Mozambique", ISO2: "MZ", ISO3: "MOZ" },
  { name: "Myanmar", ISO2: "MM", ISO3: "MMR" },
  { name: "Namibia", ISO2: "NA", ISO3: "NAM" },
  { name: "Nauru", ISO2: "NR", ISO3: "NRU" },
  { name: "Nepal", ISO2: "NP", ISO3: "NPL" },
  { name: "Netherlands", ISO2: "NL", ISO3: "NLD" },
  { name: "New Zealand", ISO2: "NZ", ISO3: "NZL" },
  { name: "Nicaragua", ISO2: "NI", ISO3: "NIC" },
  { name: "North Korea", ISO2: "KP", ISO3: "PRK" },
  { name: "South Korea", ISO2: "KR", ISO3: "KOR" },
  { name: "Niger", ISO2: "NE", ISO3: "NER" },
  { name: "Nigeria", ISO2: "NG", ISO3: "NGA" },
  { name: "North Macedonia", ISO2: "MK", ISO3: "MKD" },
  { name: "Norway", ISO2: "NO", ISO3: "NOR" },
  { name: "Oman", ISO2: "OM", ISO3: "OMN" },
  { name: "Pakistan", ISO2: "PK", ISO3: "PAK" },
  { name: "Palau", ISO2: "PW", ISO3: "PLW" },
  { name: "Panama", ISO2: "PA", ISO3: "PAN" },
  { name: "Papua New Guinea", ISO2: "PG", ISO3: "PNG" },
  { name: "Paraguay", ISO2: "PY", ISO3: "PRY" },
  { name: "Peru", ISO2: "PE", ISO3: "PER" },
  { name: "Philippines", ISO2: "PH", ISO3: "PHL" },
  { name: "Poland", ISO2: "PL", ISO3: "POL" },
  { name: "Portugal", ISO2: "PT", ISO3: "PRT" },
  { name: "Qatar", ISO2: "QA", ISO3: "QAT" },
  { name: "Romania", ISO2: "RO", ISO3: "ROU" },
  { name: "Russia", ISO2: "RU", ISO3: "RUS" },
  { name: "Rwanda", ISO2: "RW", ISO3: "RWA" },
  { name: "Saint Kitts and Nevis", ISO2: "KN", ISO3: "KNA" },
  { name: "Saint Lucia", ISO2: "LC", ISO3: "LCA" },
  { name: "Saint Vincent and the Grenadines", ISO2: "VC", ISO3: "VCT" },
  { name: "Samoa", ISO2: "WS", ISO3: "WSM" },
  { name: "San Marino", ISO2: "SM", ISO3: "SMR" },
  { name: "Sao Tome and Principe", ISO2: "ST", ISO3: "STP" },
  { name: "São Tomé and Príncipe", ISO2: "ST", ISO3: "STP" },
  { name: "Saudi Arabia", ISO2: "SA", ISO3: "SAU" },
  { name: "Senegal", ISO2: "SN", ISO3: "SEN" },
  { name: "Serbia", ISO2: "RS", ISO3: "SRB" },
  { name: "Seychelles", ISO2: "SC", ISO3: "SYC" },
  { name: "Sierra Leone", ISO2: "SL", ISO3: "SLE" },
  { name: "Singapore", ISO2: "SG", ISO3: "SGP" },
  { name: "Slovakia", ISO2: "SK", ISO3: "SVK" },
  { name: "Slovenia", ISO2: "SI", ISO3: "SVN" },
  { name: "Solomon Islands", ISO2: "SB", ISO3: "SLB" },
  { name: "Somalia", ISO2: "SO", ISO3: "SOM" },
  { name: "South Africa", ISO2: "ZA", ISO3: "ZAF" },
  { name: "South Sudan", ISO2: "SS", ISO3: "SSD" },
  { name: "Spain", ISO2: "ES", ISO3: "ESP" },
  { name: "Sri Lanka", ISO2: "LK", ISO3: "LKA" },
  { name: "Sudan", ISO2: "SD", ISO3: "SDN" },
  { name: "Suriname", ISO2: "SR", ISO3: "SUR" },
  { name: "Sweden", ISO2: "SE", ISO3: "SWE" },
  { name: "Switzerland", ISO2: "CH", ISO3: "CHE" },
  { name: "Syria", ISO2: "SY", ISO3: "SYR" },
  { name: "Taiwan", ISO2: "TW", ISO3: "TWN" },
  { name: "Tajikistan", ISO2: "TJ", ISO3: "TJK" },
  { name: "Tanzania", ISO2: "TZ", ISO3: "TZA" },
  { name: "Thailand", ISO2: "TH", ISO3: "THA" },
  { name: "Timor-Leste", ISO2: "TL", ISO3: "TLS" },
  { name: "East Timor", ISO2: "TL", ISO3: "TLS" },
  { name: "Togo", ISO2: "TG", ISO3: "TGO" },
  { name: "Tonga", ISO2: "TO", ISO3: "TON" },
  { name: "Trinidad and Tobago", ISO2: "TT", ISO3: "TTO" },
  { name: "Tunisia", ISO2: "TN", ISO3: "TUN" },
  { name: "Turkey", ISO2: "TR", ISO3: "TUR" },
  { name: "Turkmenistan", ISO2: "TM", ISO3: "TKM" },
  { name: "Tuvalu", ISO2: "TV", ISO3: "TUV" },
  { name: "Uganda", ISO2: "UG", ISO3: "UGA" },
  { name: "Ukraine", ISO2: "UA", ISO3: "UKR" },
  { name: "United Arab Emirates", ISO2: "AE", ISO3: "ARE" },
  { name: "United Kingdom", ISO2: "GB", ISO3: "GBR" },
  { name: "United States", ISO2: "US", ISO3: "USA" },
  { name: "Uruguay", ISO2: "UY", ISO3: "URY" },
  { name: "Uzbekistan", ISO2: "UZ", ISO3: "UZB" },
  { name: "Vanuatu", ISO2: "VU", ISO3: "VUT" },
  { name: "Vatican City", ISO2: "VA", ISO3: "VAT" },
  { name: "Venezuela", ISO2: "VE", ISO3: "VEN" },
  { name: "Vietnam", ISO2: "VN", ISO3: "VNM" },
  { name: "Yemen", ISO2: "YE", ISO3: "YEM" },
  { name: "Zambia", ISO2: "ZM", ISO3: "ZMB" },
  { name: "Zimbabwe", ISO2: "ZW", ISO3: "ZWE" }
]
return {countryData};
}});

define({id: "26b37714", inputs: ["countryData"], outputs: ["isoQ"], body: (countryData) => {
function isoQ(input) {
  for (const country of countryData) {
    if (
      country.name === input ||
      country.ISO2 === input ||
      country.ISO3 === input
    ) {
      const result = { ...country };
      delete result[input];
      if (result) {
        return [[result.name, result.ISO2, result.ISO3]];
      }
    }
  }
}
return {isoQ};
}});

define({id: "c524bdaf", inputs: ["getmyCentroid","countries"], outputs: ["countryLabels"], body: (getmyCentroid,countries) => {
const countryLabels = getmyCentroid(
  countries.filter((d) => ["US"].indexOf(d.properties.ISO_A2) > -1),
  "NAME_EN"
)
return {countryLabels};
}});

define({id: "48e9abf1", inputs: ["getmyCentroid","countries"], outputs: ["getCountryLabels"], body: (getmyCentroid,countries) => {
function getCountryLabels([iso]) {
  return getmyCentroid(
    countries.filter((d) => iso.indexOf(d.properties.ISO_A2) > -1),
    "NAME_EN"
  );
}
return {getCountryLabels};
}});

define({id: "25266b90", outputs: ["scaleRange"], body: () => {
function scaleRange(start, end, breaks) {
  if (breaks < 1) {
    throw new Error("Number of breaks must be at least 1");
  }

  const stepSize = (end - start) / (breaks - 1);
  const scaleRange = [];

  for (let i = 0; i < breaks; i++) {
    scaleRange.push(start + i * stepSize);
  }

  return scaleRange;
}
return {scaleRange};
}});

define({id: "404f59f1", outputs: ["scaleBreak"], body: () => {
function scaleBreak(start, end, breakValue) {
  if (breakValue <= 0) {
    throw new Error("Break value must be greater than 0");
  }

  const scaleRange = [];
  let currentValue = start;

  while (currentValue <= end) {
    scaleRange.push(currentValue);
    currentValue += breakValue;
  }

  return scaleRange;
}
return {scaleBreak};
}});

define({id: "4c994a9a", outputs: ["scaleCircle"], body: () => {
function scaleCircle(vi, vl, rl) {
  if (vi > 1) {
    if (Math.sqrt(vi / vl) * rl > 1) {
      return Math.sqrt(vi / vl) * rl;
    } else {
      return 1;
    }
  } else {
    return 1;
  }
}
return {scaleCircle};
}});

define({id: "7069867e", outputs: ["osmBbox"], body: () => {
function osmBbox(bbox) {
  // bbox is in the format [w, s, e, n]
  return [bbox[1], bbox[0], bbox[3], bbox[2]];
}
return {osmBbox};
}});

define({id: "a6f39d2a", inputs: ["getmyCentroid","provinces"], outputs: ["states"], body: (getmyCentroid,provinces) => {
const states = getmyCentroid(
  provinces.filter((d) => d.properties.iso_a2 == "UA"),
  "name"
)
return {states};
}});

define({id: "eeb2f35d", inputs: ["queryOverpass","turf","geojsonrewind"], outputs: ["addOSM"], body: (queryOverpass,turf,geojsonrewind) => {
function addOSM(mytarget) {
  var x = 0;
  console.log(mytarget);
  function myLoop() {
    setTimeout(function () {
      var target = mytarget[x];
      queryOverpass(
        "[out:json][timeout:900];(" + target + ";);out body;>;out skel qt;",
        function (err, geojson) {
          if (err) {
            console.log(err);
          } else {
            // console.log(geojson)
            var options = { tolerance: 0.01, highQuality: false };
            var simplified = turf.simplify(
              geojsonrewind(geojson, true),
              options
            );
            return simplified.features;
          }
        }
      );
      x++;
      if (x < mytarget.length) {
        myLoop();
      }
    }, 1000);
  }
  myLoop();
}
return {addOSM};
}});

define({id: "3bb28735", inputs: ["queryOverpass","turf","geojsonrewind"], outputs: ["getOSM"], body: (queryOverpass,turf,geojsonrewind) => {
async function getOSM(query, format, smooth, tolerance) {
  // Wrap the queryOverpass call in a new Promise
  if (format == "csv") {
    const data = await new Promise((resolve, reject) => {
      queryOverpass(
        `[out:${format}][timeout:900];(${query};);out body;>;out skel qt;`,
        function (err, result) {
          if (err) {
            console.log("error");
            reject(err); // Reject the Promise if there's an error
          } else {
            console.log("sucess");
            resolve(result);
          }
          //console.log(err, result);
        }
      );
    });
    return data;
  }
  if (format == "geojson" || format == "json") {
    const data = await new Promise((resolve, reject) => {
      queryOverpass(
        `[out:${format}][timeout:900];(${query};);out body;>;out skel qt;`,
        function (err, geojson) {
          if (err) {
            reject(err); // Reject the Promise if there's an error
          } else {
            if (smooth) {
              var options = {
                tolerance: tolerance ?? 0.01,
                highQuality: false
              };
              var simplified = turf.simplify(
                geojsonrewind(geojson, true),
                options
              );
              //console.log("simplified:" + geojsonrewind(geojson, true));
              resolve(simplified.features); // Resolve the Promise with your data
            } else {
              //console.log(geojsonrewind(geojson, true));
              resolve(geojsonrewind(geojson, true));
            }
          }
        }
      );
    });
    return data;
  }
}
return {getOSM};
}});

define({id: "4ed27055", inputs: ["d3"], outputs: ["overPass"], body: (d3) => {
async function overPass(format, query, simplified, tolerance) {
  try {
    let api = "https://overpass-api.de/api/interpreter";
    let encodedQuery = `[out:${format}][timeout:900];(${query});out;`;
    let url = `${api}?data=${encodedQuery}`;
    console.log(url);
    let response;
    if (format === "csv") {
      response = await d3.csv(url);
    } else if (format === "json") {
      response = await d3.json(url);
    } else {
      throw new Error("Invalid format specified");
    }

    console.log(response); // Process your data here
    return response; // Optionally return the data
  } catch (error) {
    console.error("Error fetching data:", error);
  }
}
return {overPass};
}});

</script>
<input id="observablehq-sidebar-toggle" type="checkbox" title="Toggle sidebar">
<label id="observablehq-sidebar-backdrop" for="observablehq-sidebar-toggle"></label>
<nav id="observablehq-sidebar">
  <ol>
    <label id="observablehq-sidebar-close" for="observablehq-sidebar-toggle"></label>
    <li class="observablehq-link"><a href="./">Portfolio</a></li>
  </ol>
  <section>
    <summary>Examples</summary>
    <ol>
    <li class="observablehq-link"><a href="./make-a-map">🗺️ Make A Map (Mapa)</a></li>
    </ol>
  </section>
</nav>
<script>{Object.assign(document.createElement("a"),{href:""}).password&&location.replace(location.href);const e=document.querySelector("#observablehq-sidebar"),t=document.querySelector("#observablehq-sidebar-toggle"),r=sessionStorage.getItem("observablehq-sidebar");r?t.checked=r==="true":t.indeterminate=!0;for(const o of document.querySelectorAll("#observablehq-sidebar summary")){const s=o.parentElement;switch(sessionStorage.getItem(`observablehq-sidebar:${o.textContent}`)){case"true":s.open=!0;break;case"false":s.classList.contains("observablehq-section-active")||(s.open=!1);break}}addEventListener("beforeunload",()=>sessionStorage.setItem("observablehq-sidebar-scrolly",`${e.scrollTop}`));const a=sessionStorage.getItem("observablehq-sidebar-scrolly");a!=null&&(e.style.cssText="overflow: hidden;",e.scrollTop=+a,e.style.cssText="");}</script>
<aside id="observablehq-toc" data-selector="h1:not(:first-of-type)[id], h2:first-child[id], :not(h1) + h2[id]">
<nav>
</nav>
</aside>
<div id="observablehq-center">
<main id="observablehq-main" class="observablehq">
<div class="observablehq observablehq--block"><!--:264cc6da:--></div>
<div class="observablehq observablehq--block"><!--:25c8f605:--></div>
<div class="observablehq observablehq--block"><!--:b5a42bc1:--></div>
<div class="observablehq observablehq--block"><!--:4b1a18a7:--></div>
<hr>
<div class="observablehq observablehq--block"><!--:2e8be929:--></div>
<div class="observablehq observablehq--block"><!--:a5f908ce:--></div>
<pre data-language="js"><code class="language-js">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Mapa</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">
    props = {
      width: <span class="hljs-literal">null</span>,
      height: <span class="hljs-literal">null</span>,
      bounds: <span class="hljs-literal">null</span>,
      clipping: <span class="hljs-literal">null</span>,
      projection: <span class="hljs-literal">null</span>,
      rotation: <span class="hljs-literal">null</span>,
      basemap: <span class="hljs-literal">null</span>,
      layer: {
        points: { show: <span class="hljs-literal">false</span>, data: <span class="hljs-literal">null</span> },
        polys: { show: <span class="hljs-literal">false</span>, data: <span class="hljs-literal">null</span> },
        tiles: { show: <span class="hljs-literal">false</span>, data: <span class="hljs-literal">null</span> },
        grids: { show: <span class="hljs-literal">false</span>, data: <span class="hljs-literal">null</span> }
      },
      scalebar: <span class="hljs-literal">null</span>,
      label: <span class="hljs-literal">null</span>,
      style: <span class="hljs-literal">null</span>,
      graphic: <span class="hljs-literal">null</span>
    }
  </span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = props.<span class="hljs-property">width</span> ? props.<span class="hljs-property">width</span> : defaultSettings.<span class="hljs-property">width</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = props.<span class="hljs-property">height</span> ? props.<span class="hljs-property">height</span> : defaultSettings.<span class="hljs-property">height</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span> = props.<span class="hljs-property">basemap</span> ? props.<span class="hljs-property">basemap</span> : defaultSettings.<span class="hljs-property">basemap</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span> = props.<span class="hljs-property">projection</span>
      ? props.<span class="hljs-property">projection</span>
      : defaultSettings.<span class="hljs-property">projection</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">rotation</span> = props.<span class="hljs-property">rotation</span> ? props.<span class="hljs-property">rotation</span> : defaultSettings.<span class="hljs-property">rotation</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span> = props.<span class="hljs-property">layer</span> ? props.<span class="hljs-property">layer</span> : defaultSettings.<span class="hljs-property">layer</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">scalebar</span> = props.<span class="hljs-property">scalebar</span> ? props.<span class="hljs-property">scalebar</span> : defaultSettings.<span class="hljs-property">scalebar</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bounds</span> = props.<span class="hljs-property">bounds</span> ? props.<span class="hljs-property">bounds</span> : defaultSettings.<span class="hljs-property">bounds</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">clipping</span> = props.<span class="hljs-property">clipping</span> ? props.<span class="hljs-property">clipping</span> : defaultSettings.<span class="hljs-property">clipping</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = props.<span class="hljs-property">label</span> ? props.<span class="hljs-property">label</span> : defaultSettings.<span class="hljs-property">label</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">graphic</span> = props.<span class="hljs-property">graphic</span> ? props.<span class="hljs-property">graphic</span> : defaultSettings.<span class="hljs-property">graphic</span>;
  }
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">render</span>() {
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Layer</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">
        props = {
          geometry: <span class="hljs-literal">null</span>,
          style: <span class="hljs-literal">null</span>,
          group: <span class="hljs-literal">null</span>,
          path: <span class="hljs-literal">null</span>,
          type: <span class="hljs-literal">null</span>,
          scale: <span class="hljs-literal">null</span>
        }
      </span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">geometry</span> = props.<span class="hljs-property">geometry</span> ? props.<span class="hljs-property">geometry</span> : <span class="hljs-literal">null</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">filter</span> = props.<span class="hljs-property">filter</span>
          ? props.<span class="hljs-property">filter</span>
          : { <span class="hljs-attr">show</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> };
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span> = props.<span class="hljs-property">style</span>
          ? props.<span class="hljs-property">style</span>
          : {
              <span class="hljs-attr">stroke</span>: <span class="hljs-literal">null</span>,
              <span class="hljs-string">"stroke-dasharray"</span>: <span class="hljs-literal">null</span>,
              <span class="hljs-string">"stroke-dashoffset"</span>: <span class="hljs-literal">null</span>,
              <span class="hljs-string">"stroke-linecap"</span>: <span class="hljs-literal">null</span>,
              <span class="hljs-string">"stroke-linejoin"</span>: <span class="hljs-literal">null</span>,
              <span class="hljs-string">"stroke-miterlimit"</span>: <span class="hljs-literal">null</span>,
              <span class="hljs-string">"stroke-opacity"</span>: <span class="hljs-literal">null</span>,
              <span class="hljs-string">"stroke-width"</span>: <span class="hljs-literal">null</span>,
              <span class="hljs-attr">fill</span>: <span class="hljs-literal">null</span>,
              <span class="hljs-attr">radius</span>: <span class="hljs-literal">null</span>,
              <span class="hljs-string">"fill-opacity"</span>: <span class="hljs-literal">null</span>,
              <span class="hljs-attr">opacity</span>: <span class="hljs-literal">null</span>,
              <span class="hljs-attr">type</span>: <span class="hljs-literal">null</span>
            };
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span> = props.<span class="hljs-property">group</span> ? props.<span class="hljs-property">group</span> : <span class="hljs-literal">null</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">path</span> = props.<span class="hljs-property">path</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = props.<span class="hljs-property">type</span> ? props.<span class="hljs-property">type</span> : <span class="hljs-literal">null</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">scale</span> = props.<span class="hljs-property">scale</span> ? props.<span class="hljs-property">scale</span> : <span class="hljs-literal">null</span>;
      }
      <span class="hljs-keyword">get</span> <span class="hljs-title function_">add</span>() {
        <span class="hljs-keyword">let</span> filter = <span class="hljs-variable language_">this</span>.<span class="hljs-property">filter</span>;
        <span class="hljs-keyword">let</span> group = <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>;
        <span class="hljs-keyword">let</span> geometry = <span class="hljs-variable language_">this</span>.<span class="hljs-property">geometry</span>;
        <span class="hljs-keyword">let</span> style = <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>;
        <span class="hljs-keyword">let</span> path = <span class="hljs-variable language_">this</span>.<span class="hljs-property">path</span>;
        <span class="hljs-keyword">let</span> layer = <span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>;
        <span class="hljs-keyword">let</span> data = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">let</span> scale = <span class="hljs-variable language_">this</span>.<span class="hljs-property">scale</span>;
        <span class="hljs-keyword">let</span> type = <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> == <span class="hljs-string">"Point"</span>) {
          <span class="hljs-keyword">return</span> group
            .<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)
            .<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">"circle"</span>)
            .<span class="hljs-title function_">data</span>(geometry)
            .<span class="hljs-title function_">enter</span>()
            .<span class="hljs-title function_">append</span>(<span class="hljs-string">"circle"</span>)
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"cx"</span>, <span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> <span class="hljs-title function_">projection</span>(d.<span class="hljs-property">geometry</span>.<span class="hljs-property">coordinates</span>)[<span class="hljs-number">0</span>])
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"cy"</span>, <span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> <span class="hljs-title function_">projection</span>(d.<span class="hljs-property">geometry</span>.<span class="hljs-property">coordinates</span>)[<span class="hljs-number">1</span>])
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"r"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">radius</span> ?? <span class="hljs-string">"4"</span>) <span class="hljs-comment">// Set the radius here</span>
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke-opacity"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-opacity"</span>] ?? <span class="hljs-string">"1"</span>)
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke"</span>] ?? <span class="hljs-string">"black"</span>)
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke-width"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>] ?? <span class="hljs-string">"none"</span>)
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span> ?? <span class="hljs-string">"none"</span>)
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill-opacity"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"fill-opacity"</span>] ?? <span class="hljs-string">"1"</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">geometry</span>.<span class="hljs-property">type</span> == <span class="hljs-string">"Topology"</span>) {
          data = topojson.<span class="hljs-title function_">feature</span>(
            geometry,
            geometry.<span class="hljs-property">objects</span>[<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(geometry.<span class="hljs-property">objects</span>)[<span class="hljs-number">0</span>]] <span class="hljs-comment">// 😅</span>
          ).<span class="hljs-property">features</span>;

          <span class="hljs-keyword">if</span> (filter.<span class="hljs-property">show</span>) {
            data = data.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) {
              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(filter.<span class="hljs-property">key</span>, d.<span class="hljs-property">properties</span>, d.<span class="hljs-property">properties</span>[filter.<span class="hljs-property">key</span>]);
              <span class="hljs-keyword">if</span> (d.<span class="hljs-property">properties</span>[filter.<span class="hljs-property">key</span>] == filter.<span class="hljs-property">value</span>) {
                <span class="hljs-keyword">return</span> d;
              }
            });

            <span class="hljs-comment">//console.log(data.length);</span>
          }
          <span class="hljs-keyword">return</span> group
            .<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)
            .<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">"path"</span>)
            .<span class="hljs-title function_">data</span>(data)
            .<span class="hljs-title function_">enter</span>()
            .<span class="hljs-title function_">append</span>(<span class="hljs-string">"path"</span>)
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"d"</span>, path)
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">stroke</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">stroke</span> : <span class="hljs-string">"none"</span>)
            .<span class="hljs-title function_">attr</span>(
              <span class="hljs-string">"stroke-dasharray"</span>,
              <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-dasharray"</span>]
                ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-dasharray"</span>]
                : <span class="hljs-string">"none"</span>
            )
            .<span class="hljs-title function_">attr</span>(
              <span class="hljs-string">"stroke-dashoffset"</span>,
              <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-dashoffset"</span>]
                ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-dashoffset"</span>]
                : <span class="hljs-string">"none"</span>
            )
            .<span class="hljs-title function_">attr</span>(
              <span class="hljs-string">"stroke-linecap"</span>,
              <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-linecap"</span>]
                ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-linecap"</span>]
                : <span class="hljs-string">"round"</span>
            )
            .<span class="hljs-title function_">attr</span>(
              <span class="hljs-string">"stroke-linejoin"</span>,
              <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-linejoin"</span>]
                ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-linejoin"</span>]
                : <span class="hljs-string">"round"</span>
            )
            .<span class="hljs-title function_">attr</span>(
              <span class="hljs-string">"stroke-miterlimit"</span>,
              <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-miterlimit"</span>]
                ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-miterlimit"</span>]
                : <span class="hljs-string">"4"</span>
            )
            .<span class="hljs-title function_">attr</span>(
              <span class="hljs-string">"stroke-opacity"</span>,
              <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-opacity"</span>] ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-opacity"</span>] : <span class="hljs-string">"1"</span>
            )
            .<span class="hljs-title function_">attr</span>(
              <span class="hljs-string">"stroke-width"</span>,
              <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>] ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>] : <span class="hljs-string">"none"</span>
            )
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span> : <span class="hljs-string">"none"</span>)
            .<span class="hljs-title function_">attr</span>(
              <span class="hljs-string">"fill-opacity"</span>,
              <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"fill-opacity"</span>] ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"fill-opacity"</span>] : <span class="hljs-string">"1"</span>
            )
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"opacity"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span> : <span class="hljs-string">"1"</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> == <span class="hljs-string">"qtree"</span>) {
            <span class="hljs-keyword">return</span> group
              .<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)
              .<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">"circle"</span>)
              .<span class="hljs-title function_">data</span>(geometry)
              .<span class="hljs-title function_">enter</span>()
              .<span class="hljs-title function_">append</span>(<span class="hljs-string">"circle"</span>)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"cx"</span>, <span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-title function_">projection</span>(d.<span class="hljs-property">geometry</span>.<span class="hljs-property">coordinates</span>)[<span class="hljs-number">0</span>];
              })
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"cy"</span>, <span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-title function_">projection</span>(d.<span class="hljs-property">geometry</span>.<span class="hljs-property">coordinates</span>)[<span class="hljs-number">1</span>];
              })
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"r"</span>, <span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-title function_">scale</span>(d.<span class="hljs-property">properties</span>.<span class="hljs-property">count</span>);
              })
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"data-count"</span>, <span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> {
                <span class="hljs-keyword">return</span> d.<span class="hljs-property">properties</span>.<span class="hljs-property">count</span>;
              })
              .<span class="hljs-title function_">attr</span>(
                <span class="hljs-string">"stroke-opacity"</span>,
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-opacity"</span>]
                  ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-opacity"</span>]
                  : <span class="hljs-string">"1"</span>
              )
              .<span class="hljs-title function_">attr</span>(
                <span class="hljs-string">"stroke"</span>,
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke"</span>] ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke"</span>] : <span class="hljs-string">"black"</span>
              )
              .<span class="hljs-title function_">attr</span>(
                <span class="hljs-string">"stroke-width"</span>,
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>] ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>] : <span class="hljs-string">"none"</span>
              )
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span> : <span class="hljs-string">"none"</span>)
              .<span class="hljs-title function_">attr</span>(
                <span class="hljs-string">"fill-opacity"</span>,
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"fill-opacity"</span>] ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"fill-opacity"</span>] : <span class="hljs-string">"1"</span>
              );
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> group
              .<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)
              .<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">"path"</span>)
              .<span class="hljs-title function_">data</span>(geometry)
              .<span class="hljs-title function_">enter</span>()
              .<span class="hljs-title function_">append</span>(<span class="hljs-string">"path"</span>)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"d"</span>, path)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">stroke</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">stroke</span> : <span class="hljs-string">"none"</span>)
              .<span class="hljs-title function_">attr</span>(
                <span class="hljs-string">"stroke-dasharray"</span>,
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-dasharray"</span>]
                  ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-dasharray"</span>]
                  : <span class="hljs-string">"none"</span>
              )
              .<span class="hljs-title function_">attr</span>(
                <span class="hljs-string">"stroke-dashoffset"</span>,
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-dashoffset"</span>]
                  ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-dashoffset"</span>]
                  : <span class="hljs-string">"none"</span>
              )
              .<span class="hljs-title function_">attr</span>(
                <span class="hljs-string">"stroke-linecap"</span>,
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-linecap"</span>]
                  ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-linecap"</span>]
                  : <span class="hljs-string">"butt"</span>
              )
              .<span class="hljs-title function_">attr</span>(
                <span class="hljs-string">"stroke-linejoin"</span>,
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-linejoin"</span>]
                  ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-linejoin"</span>]
                  : <span class="hljs-string">"round"</span>
              )
              .<span class="hljs-title function_">attr</span>(
                <span class="hljs-string">"stroke-miterlimit"</span>,
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-miterlimit"</span>]
                  ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-miterlimit"</span>]
                  : <span class="hljs-string">"4"</span>
              )
              .<span class="hljs-title function_">attr</span>(
                <span class="hljs-string">"stroke-opacity"</span>,
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-opacity"</span>]
                  ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-opacity"</span>]
                  : <span class="hljs-string">"1"</span>
              )
              .<span class="hljs-title function_">attr</span>(
                <span class="hljs-string">"stroke-width"</span>,
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>] ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>] : <span class="hljs-string">"none"</span>
              )
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span> : <span class="hljs-string">"none"</span>)
              .<span class="hljs-title function_">attr</span>(
                <span class="hljs-string">"fill-opacity"</span>,
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"fill-opacity"</span>] ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"fill-opacity"</span>] : <span class="hljs-string">"1"</span>
              )
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"opacity"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span> : <span class="hljs-string">"1"</span>);
          }
        }
      }
    }
    <span class="hljs-keyword">let</span> uid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>).<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);

    <span class="hljs-keyword">let</span> margin = <span class="hljs-variable language_">this</span>.<span class="hljs-property">clipping</span>.<span class="hljs-property">margin</span>;
    <span class="hljs-keyword">let</span> width = <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span>;
    <span class="hljs-keyword">let</span> height = <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span>;
    <span class="hljs-keyword">let</span> basemap = <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>;

    <span class="hljs-keyword">const</span> sphere = { <span class="hljs-attr">type</span>: <span class="hljs-string">"Sphere"</span> };
    <span class="hljs-keyword">const</span> country = <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">land</span>.<span class="hljs-property">geometry</span>;

    <span class="hljs-keyword">let</span> projection = <span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">proj</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">type</span> == <span class="hljs-string">"proj4"</span>) {
      <span class="hljs-keyword">function</span> <span class="hljs-title function_">degreesToRadians</span>(<span class="hljs-params">degrees</span>) {
        <span class="hljs-keyword">return</span> (degrees * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) / <span class="hljs-number">180</span>;
      }
      <span class="hljs-keyword">function</span> <span class="hljs-title function_">radiansToDegrees</span>(<span class="hljs-params">radians</span>) {
        <span class="hljs-keyword">return</span> (radians * <span class="hljs-number">180</span>) / <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>;
      }

      <span class="hljs-keyword">let</span> check = <span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">proj</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> [<span class="hljs-string">"+x_0=0"</span>, <span class="hljs-string">"+y_0=0"</span>]) {
        <span class="hljs-keyword">if</span> (check.<span class="hljs-title function_">indexOf</span>(x) == -<span class="hljs-number">1</span>) {
          check.<span class="hljs-title function_">push</span>(x);
        }
      }
      projection = check.<span class="hljs-title function_">join</span>(<span class="hljs-string">" "</span>);

      <span class="hljs-keyword">let</span> projTarget = <span class="hljs-title function_">proj4</span>(projection);
      <span class="hljs-keyword">let</span> project4 = <span class="hljs-keyword">function</span> (<span class="hljs-params">lambda, phi</span>) {
        <span class="hljs-keyword">return</span> projTarget.<span class="hljs-title function_">forward</span>([lambda, phi].<span class="hljs-title function_">map</span>(radiansToDegrees));
      };
      project4.<span class="hljs-property">invert</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) {
        <span class="hljs-keyword">return</span> projTarget.<span class="hljs-title function_">inverse</span>([x, y]).<span class="hljs-title function_">map</span>(degreesToRadians);
      };

      projection = d3
        .<span class="hljs-title function_">geoProjection</span>(project4)
        .<span class="hljs-title function_">fitExtent</span>(
          [
            [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
            [width, height]
          ],
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">bounds</span>.<span class="hljs-property">feature</span>
        )
        .<span class="hljs-title function_">preclip</span>(d3.<span class="hljs-property">geoClipAntimeridian</span>); <span class="hljs-comment">//</span>
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">type</span> == <span class="hljs-string">"raw"</span>) {
      projection = <span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">proj</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">type</span> == <span class="hljs-string">"clip"</span>) {
      projection = <span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">proj</span>.<span class="hljs-title function_">clipAngle</span>(<span class="hljs-number">180</span>);
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">type</span> == <span class="hljs-string">"custom"</span>) {
      projection = <span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">proj</span>
        .<span class="hljs-title function_">translate</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">translate</span>)
        .<span class="hljs-title function_">scale</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">scale</span>)
        .<span class="hljs-title function_">center</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">center</span>)
        .<span class="hljs-title function_">rotate</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">rotate</span>)
        .<span class="hljs-title function_">tilt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">tilt</span>)
        .<span class="hljs-title function_">distance</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">distance</span>)
        .<span class="hljs-title function_">clipAngle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">clipAngle</span>)
        .<span class="hljs-title function_">precision</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">precision</span>);
    }

    <span class="hljs-keyword">if</span> (height == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">const</span> [[x0, y0], [x1, y1]] = d3
        .<span class="hljs-title function_">geoPath</span>(projection.<span class="hljs-title function_">fitWidth</span>(width, sphere))
        .<span class="hljs-title function_">bounds</span>(sphere);
      <span class="hljs-keyword">const</span> dy = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(y1 - y0),
        l = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(x1 - x0), dy);
      projection.<span class="hljs-title function_">scale</span>((projection.<span class="hljs-title function_">scale</span>() * (l - <span class="hljs-number">1</span>)) / l).<span class="hljs-title function_">precision</span>(<span class="hljs-number">0.2</span>);
      height = dy;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">fit</span> == <span class="hljs-string">"none"</span>) {
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">bounds</span>.<span class="hljs-property">bounder</span>) {
      projection.<span class="hljs-title function_">fitSize</span>([width, height], <span class="hljs-variable language_">this</span>.<span class="hljs-property">bounds</span>.<span class="hljs-property">feature</span>);
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">fit</span> == <span class="hljs-string">"iso2"</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">bounds</span>.<span class="hljs-property">countries</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">let</span> list = <span class="hljs-variable language_">this</span>.<span class="hljs-property">bounds</span>.<span class="hljs-property">countries</span>;
        <span class="hljs-keyword">let</span> filteredCountries = countries.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">d, i</span>) {
          <span class="hljs-keyword">if</span> (list.<span class="hljs-title function_">indexOf</span>(d.<span class="hljs-property">properties</span>.<span class="hljs-property">ISO_A2</span>) &gt; -<span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> d;
          }
        });

        projection.<span class="hljs-title function_">fitSize</span>(
          [width, height],
          turf.<span class="hljs-title function_">featureCollection</span>(filteredCountries)
        );
      }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">fit</span> == <span class="hljs-string">"iso3"</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">bounds</span>.<span class="hljs-property">countries</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">let</span> list = <span class="hljs-variable language_">this</span>.<span class="hljs-property">bounds</span>.<span class="hljs-property">countries</span>;
        <span class="hljs-keyword">let</span> filteredCountries = countries.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">d, i</span>) {
          <span class="hljs-keyword">if</span> (list.<span class="hljs-title function_">indexOf</span>(d.<span class="hljs-property">properties</span>.<span class="hljs-property">ISO_A3</span>) &gt; -<span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> d;
          }
        });

        projection.<span class="hljs-title function_">fitSize</span>(
          [width, height],
          turf.<span class="hljs-title function_">featureCollection</span>(filteredCountries)
        );
      }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">fit</span> == <span class="hljs-string">"size"</span>) {
      projection.<span class="hljs-title function_">fitSize</span>([width, height], sphere);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">projection</span>.<span class="hljs-property">fit</span> == <span class="hljs-string">"extent"</span>) {
      projection.<span class="hljs-title function_">fitExtent</span>(
        [
          [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
          [width, height]
        ],
        sphere
      );
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">clipping</span>.<span class="hljs-property">clip</span>) {
      <span class="hljs-keyword">function</span> <span class="hljs-title function_">viewport</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">let</span> n = <span class="hljs-number">15</span>;
        <span class="hljs-keyword">let</span> p = -<span class="hljs-number">1</span> * margin;

        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">type</span>: <span class="hljs-string">"Polygon"</span>,
          <span class="hljs-attr">coordinates</span>: [
            [
              ...<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: n }, <span class="hljs-function">(<span class="hljs-params">_, t</span>) =&gt;</span> [
                p + ((width - p * <span class="hljs-number">2</span>) * t) / n,
                p
              ]),
              ...<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: n }, <span class="hljs-function">(<span class="hljs-params">_, t</span>) =&gt;</span> [
                width - p,
                ((height - p * <span class="hljs-number">2</span>) * t) / n + p
              ]),
              ...<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: n }, <span class="hljs-function">(<span class="hljs-params">_, t</span>) =&gt;</span> [
                p + ((width - p * <span class="hljs-number">2</span>) * (n - t)) / n,
                height - p
              ]),
              ...<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: n }, <span class="hljs-function">(<span class="hljs-params">_, t</span>) =&gt;</span> [
                p,
                ((height - p * <span class="hljs-number">2</span>) * (n - t)) / n + p
              ]),
              [p, p]
            ].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> projection.<span class="hljs-title function_">invert</span>(p))
          ]
        };
      }
      <span class="hljs-keyword">let</span> v = {
        <span class="hljs-attr">type</span>: <span class="hljs-string">"Polygon"</span>,
        <span class="hljs-attr">coordinates</span>: [
          <span class="hljs-title function_">viewport</span>().<span class="hljs-property">coordinates</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">map</span>(d3.<span class="hljs-title function_">geoRotation</span>(projection.<span class="hljs-title function_">rotate</span>()))
        ]
      };
      <span class="hljs-keyword">let</span> clipPolygon = d3.<span class="hljs-title function_">geoClipPolygon</span>(v);
      projection.<span class="hljs-title function_">preclip</span>(clipPolygon);
    }

    <span class="hljs-keyword">let</span> path = d3.<span class="hljs-title function_">geoPath</span>().<span class="hljs-title function_">projection</span>(projection);

    <span class="hljs-keyword">let</span> rotation = <span class="hljs-variable language_">this</span>.<span class="hljs-property">rotation</span>.<span class="hljs-property">value</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">rotation</span>.<span class="hljs-property">value</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) {
      rotation = <span class="hljs-variable language_">this</span>.<span class="hljs-property">rotation</span>.<span class="hljs-property">value</span>;
    } <span class="hljs-keyword">else</span> {
      rotation = [<span class="hljs-variable language_">this</span>.<span class="hljs-property">rotation</span>.<span class="hljs-property">value</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">rotation</span>.<span class="hljs-property">rotate</span>) {
      projection.<span class="hljs-title function_">rotate</span>(rotation);
    }

      <span class="hljs-comment">// Create and setup SVG with UID</span>
    <span class="hljs-keyword">const</span> svg = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElementNS</span>(<span class="hljs-string">"http://www.w3.org/2000/svg"</span>, <span class="hljs-string">"svg"</span>);
    <span class="hljs-keyword">let</span> layers = <span class="hljs-variable language_">this</span>.<span class="hljs-property">layers</span>;
    <span class="hljs-keyword">const</span> graphic = d3
      .<span class="hljs-title function_">select</span>(svg)
      .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"width"</span>, width)
      .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"height"</span>, height)
      .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, uid)  <span class="hljs-comment">// Using the UID as id</span>
      .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"graphic"</span>)
      .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"vector-effect"</span>, <span class="hljs-string">"non-scaling-stroke"</span>)
      .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke-linejoin"</span>, <span class="hljs-string">"round"</span>);

    <span class="hljs-keyword">let</span> graster = graphic.<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"rasterlayer"</span>); <span class="hljs-comment">//bottom</span>
    <span class="hljs-keyword">let</span> gbasemap = graphic.<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"basemap"</span>);
    <span class="hljs-keyword">let</span> glayer = graphic.<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"layers"</span>);
    <span class="hljs-keyword">let</span> gsymbol = graphic.<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"symbols"</span>);
    <span class="hljs-keyword">let</span> glabel = graphic.<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"labels"</span>);
    <span class="hljs-keyword">let</span> gscalebar = graphic.<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"scalebar"</span>);
    <span class="hljs-keyword">let</span> gannotation = graphic.<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"annotations"</span>); <span class="hljs-comment">//top</span>
    <span class="hljs-keyword">let</span> ggrid = graphic.<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"grid"</span>);

    graster.<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"raster"</span>);

    <span class="hljs-keyword">let</span> scalebar = <span class="hljs-variable language_">this</span>.<span class="hljs-property">scalebar</span>;
    <span class="hljs-keyword">if</span> (scalebar.<span class="hljs-property">show</span>) {
      <span class="hljs-keyword">const</span> mapUnits = {
        <span class="hljs-attr">km</span>: d3.<span class="hljs-property">geoScaleKilometers</span>,
        <span class="hljs-attr">mi</span>: d3.<span class="hljs-property">geoScaleMiles</span>,
        <span class="hljs-attr">ft</span>: d3.<span class="hljs-property">geoScaleFeet</span>,
        <span class="hljs-attr">m</span>: d3.<span class="hljs-property">geoScaleMeters</span>,
        <span class="hljs-attr">kilometers</span>: d3.<span class="hljs-property">geoScaleKilometers</span>,
        <span class="hljs-attr">miles</span>: d3.<span class="hljs-property">geoScaleMiles</span>,
        <span class="hljs-attr">feet</span>: d3.<span class="hljs-property">geoScaleFeet</span>,
        <span class="hljs-attr">meters</span>: d3.<span class="hljs-property">geoScaleMeters</span>
      };
      <span class="hljs-keyword">const</span> mapScale = gscalebar
        .<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"transform"</span>,
          <span class="hljs-string">`translate(<span class="hljs-subst">${width - scalebar.position[<span class="hljs-number">0</span>]}</span>, <span class="hljs-subst">${
            height - scalebar.position[<span class="hljs-number">1</span>]
          }</span>)`</span>
        );

      <span class="hljs-keyword">var</span> stop = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> sleft = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">const</span> scaleBarTop = d3
        .<span class="hljs-title function_">geoScaleBar</span>()
        .<span class="hljs-title function_">projection</span>(projection)
        .<span class="hljs-title function_">size</span>([width, height])
        .<span class="hljs-title function_">orient</span>(d3.<span class="hljs-property">geoScaleTop</span>)
        .<span class="hljs-title function_">units</span>(mapUnits[scalebar.<span class="hljs-property">topUnit</span>])
        .<span class="hljs-title function_">distance</span>(scalebar.<span class="hljs-property">topValue</span>)
        .<span class="hljs-title function_">left</span>(sleft)
        .<span class="hljs-title function_">top</span>(stop)
        .<span class="hljs-title function_">label</span>(<span class="hljs-literal">null</span>)
        .<span class="hljs-title function_">tickPadding</span>(<span class="hljs-number">3</span>)
        .<span class="hljs-title function_">tickFormat</span>(<span class="hljs-function">(<span class="hljs-params">d, i, e</span>) =&gt;</span>
          i === e.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> ? <span class="hljs-string">`<span class="hljs-subst">${d}</span> <span class="hljs-subst">${scalebar.topUnit}</span>`</span> : d
        )
        .<span class="hljs-title function_">tickValues</span>([<span class="hljs-number">0</span>, scalebar.<span class="hljs-property">topValue</span>]);

      <span class="hljs-keyword">const</span> scaleBarBottom = d3
        .<span class="hljs-title function_">geoScaleBar</span>()
        .<span class="hljs-title function_">projection</span>(projection)
        .<span class="hljs-title function_">size</span>([width, height])
        .<span class="hljs-title function_">units</span>(mapUnits[scalebar.<span class="hljs-property">bottomUnit</span>])
        .<span class="hljs-title function_">orient</span>(d3.<span class="hljs-property">geoScaleBottom</span>)
        .<span class="hljs-title function_">distance</span>(scalebar.<span class="hljs-property">bottomValue</span>)
        .<span class="hljs-title function_">left</span>(sleft)
        .<span class="hljs-title function_">top</span>(stop)
        .<span class="hljs-title function_">label</span>(<span class="hljs-literal">null</span>)
        .<span class="hljs-title function_">tickPadding</span>(<span class="hljs-number">3</span>)
        .<span class="hljs-title function_">tickFormat</span>(<span class="hljs-function">(<span class="hljs-params">d, i, e</span>) =&gt;</span>
          i === e.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> ? <span class="hljs-string">`<span class="hljs-subst">${d}</span> <span class="hljs-subst">${scalebar.bottomUnit}</span>`</span> : d
        )
        .<span class="hljs-title function_">tickValues</span>([<span class="hljs-number">0</span>, scalebar.<span class="hljs-property">bottomValue</span>]);

      <span class="hljs-keyword">const</span> myscaleTop = mapScale
        .<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"scalebart"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"transform"</span>, <span class="hljs-string">"translate(0, -5)"</span>);

      <span class="hljs-keyword">const</span> myscaleBottom = mapScale
        .<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"scalebarb"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"transform"</span>, <span class="hljs-string">"translate(0, 5)"</span>);

      myscaleTop.<span class="hljs-title function_">call</span>(scaleBarTop);
      myscaleBottom.<span class="hljs-title function_">call</span>(scaleBarBottom);

      myscaleTop.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">"rect"</span>).<span class="hljs-title function_">remove</span>();
      myscaleBottom.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">"rect"</span>).<span class="hljs-title function_">remove</span>();

      myscaleTop.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">"path, line"</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, <span class="hljs-string">"#4B535D"</span>);
      myscaleBottom.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">"path, line"</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, <span class="hljs-string">"#4B535D"</span>);

      myscaleTop
        .<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">".tick"</span>)
        .<span class="hljs-title function_">select</span>(<span class="hljs-string">"text"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"text-anchor"</span>, <span class="hljs-string">"start"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"dx"</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">d, i</span>) {
          <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">3.5</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">4</span> * +d.<span class="hljs-title function_">toString</span>().<span class="hljs-property">length</span>;
          }
        })
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"font-size"</span>, <span class="hljs-number">14</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-string">"#4B535D"</span>);

      myscaleBottom
        .<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">".tick"</span>)
        .<span class="hljs-title function_">select</span>(<span class="hljs-string">"text"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"text-anchor"</span>, <span class="hljs-string">"start"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"dx"</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">d, i</span>) {
          <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">3.5</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">4</span> * +d.<span class="hljs-title function_">toString</span>().<span class="hljs-property">length</span>;
          }
        })
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"font-size"</span>, <span class="hljs-number">14</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-string">"#4B535D"</span>);
    }

    <span class="hljs-keyword">if</span> (basemap.<span class="hljs-property">background</span>.<span class="hljs-property">show</span>) {
      <span class="hljs-keyword">let</span> globeRect = {
        <span class="hljs-attr">type</span>: <span class="hljs-string">"Feature"</span>,
        <span class="hljs-attr">geometry</span>: {
          <span class="hljs-attr">type</span>: <span class="hljs-string">"Polygon"</span>,
          <span class="hljs-attr">coordinates</span>: [
            [
              [-<span class="hljs-number">180</span>, -<span class="hljs-number">90</span>],
              [-<span class="hljs-number">180</span>, <span class="hljs-number">90</span>],
              [<span class="hljs-number">180</span>, <span class="hljs-number">90</span>],
              [<span class="hljs-number">180</span>, -<span class="hljs-number">90</span>],
              [-<span class="hljs-number">180</span>, -<span class="hljs-number">90</span>]
            ]
          ]
        }
      };

      gbasemap
        .<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"background"</span>)
        .<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">"path"</span>)
        .<span class="hljs-title function_">data</span>([globeRect])
        .<span class="hljs-title function_">join</span>(<span class="hljs-string">"path"</span>)
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"stroke"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">background</span>.<span class="hljs-property">style</span>.<span class="hljs-property">stroke</span>
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">background</span>.<span class="hljs-property">style</span>.<span class="hljs-property">stroke</span>
            : <span class="hljs-string">"none"</span>
        )
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"fill"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">background</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span>
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">background</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span>
            : <span class="hljs-string">"none"</span>
        )
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"opacity"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">background</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span>
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">background</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span>
            : <span class="hljs-string">"1"</span>
        )
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"d"</span>, path);
    }
    <span class="hljs-keyword">if</span> (basemap.<span class="hljs-property">ocean</span>.<span class="hljs-property">show</span>) {
      gbasemap
        .<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"ocean"</span>)
        .<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">"path"</span>)
        .<span class="hljs-title function_">data</span>(oceans)
        .<span class="hljs-title function_">join</span>(<span class="hljs-string">"path"</span>)
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"stroke"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">ocean</span>.<span class="hljs-property">style</span>.<span class="hljs-property">stroke</span>
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">ocean</span>.<span class="hljs-property">style</span>.<span class="hljs-property">stroke</span>
            : <span class="hljs-string">"none"</span>
        )
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"fill"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">ocean</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">ocean</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span> : <span class="hljs-string">"none"</span>
        )
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"opacity"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">ocean</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span>
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">ocean</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span>
            : <span class="hljs-string">"1"</span>
        )
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"d"</span>, path);
    }
    <span class="hljs-keyword">if</span> (basemap.<span class="hljs-property">land</span>.<span class="hljs-property">show</span>) {
      gbasemap
        .<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"land"</span>)
        .<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">"path"</span>)
        .<span class="hljs-title function_">data</span>(countries)
        .<span class="hljs-title function_">join</span>(<span class="hljs-string">"path"</span>)
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"stroke"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">land</span>.<span class="hljs-property">style</span>.<span class="hljs-property">stroke</span>
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">land</span>.<span class="hljs-property">style</span>.<span class="hljs-property">stroke</span>
            : <span class="hljs-string">"none"</span>
        )
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"stroke-width"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">land</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>]
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">land</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>]
            : <span class="hljs-string">"none"</span>
        )
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"fill"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">land</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">land</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span> : <span class="hljs-string">"none"</span>
        )
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"opacity"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">land</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span>
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">land</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span>
            : <span class="hljs-string">"1"</span>
        )
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"d"</span>, path)
        .<span class="hljs-title function_">on</span>(<span class="hljs-string">"click"</span>, mouseClick);

      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseClick</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">let</span> tar = d3.<span class="hljs-title function_">select</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">data</span>()[<span class="hljs-number">0</span>];
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tar.<span class="hljs-property">properties</span>.<span class="hljs-property">NAME</span>);
      }
    }
    <span class="hljs-keyword">if</span> (basemap.<span class="hljs-property">border</span>.<span class="hljs-property">show</span>) {
      gbasemap
        .<span class="hljs-title function_">append</span>(<span class="hljs-string">"path"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"border"</span>)
        .<span class="hljs-title function_">datum</span>(
          topojson.<span class="hljs-title function_">mesh</span>(
            c,
            c.<span class="hljs-property">objects</span>.<span class="hljs-property">ne_10m_admin_0_countries_usa</span>,
            <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) {
              <span class="hljs-keyword">return</span> a !== b;
            }
          )
        )
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"stroke"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">border</span>.<span class="hljs-property">style</span>.<span class="hljs-property">stroke</span>
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">border</span>.<span class="hljs-property">style</span>.<span class="hljs-property">stroke</span>
            : <span class="hljs-string">"none"</span>
        )
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"stroke-width"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">border</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>]
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">border</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>]
            : <span class="hljs-string">"1"</span>
        )
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-string">"none"</span>)
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"opacity"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">border</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span>
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">border</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span>
            : <span class="hljs-string">"1"</span>
        )
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"d"</span>, path);
    }
    <span class="hljs-keyword">if</span> (basemap.<span class="hljs-property">coastline</span>.<span class="hljs-property">show</span>) {
      gbasemap
        .<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"coastline"</span>)
        .<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">"path"</span>)
        .<span class="hljs-title function_">data</span>(coastlines)
        .<span class="hljs-title function_">join</span>(<span class="hljs-string">"path"</span>)
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"stroke"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">coastline</span>.<span class="hljs-property">style</span>.<span class="hljs-property">stroke</span>
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">coastline</span>.<span class="hljs-property">style</span>.<span class="hljs-property">stroke</span>
            : <span class="hljs-string">"none"</span>
        )
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"stroke-width"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">coastline</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>]
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">coastline</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>]
            : <span class="hljs-string">"none"</span>
        )
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-string">"none"</span>)
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"opacity"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">coastline</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span>
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">coastline</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span>
            : <span class="hljs-string">"1"</span>
        )
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"d"</span>, path);
    }
    <span class="hljs-keyword">if</span> (basemap.<span class="hljs-property">lake</span>.<span class="hljs-property">show</span>) {
      gbasemap
        .<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"lakes"</span>)
        .<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">"path"</span>)
        .<span class="hljs-title function_">data</span>(lakes)
        .<span class="hljs-title function_">join</span>(<span class="hljs-string">"path"</span>)
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, <span class="hljs-string">"none"</span>)
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"stroke-width"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">lake</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>]
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">lake</span>.<span class="hljs-property">style</span>[<span class="hljs-string">"stroke-width"</span>]
            : <span class="hljs-string">"none"</span>
        )
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"fill"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">lake</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">lake</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fill</span> : <span class="hljs-string">"none"</span>
        )
        .<span class="hljs-title function_">attr</span>(
          <span class="hljs-string">"opacity"</span>,
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">lake</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span>
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">basemap</span>.<span class="hljs-property">lake</span>.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span>
            : <span class="hljs-string">"1"</span>
        )
        .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"d"</span>, path);
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">polys</span>.<span class="hljs-property">show</span>) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> l <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">polys</span>.<span class="hljs-property">data</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">polys</span>.<span class="hljs-property">data</span>[l]);
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Layer</span>({
          <span class="hljs-attr">geometry</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">polys</span>.<span class="hljs-property">data</span>[l].<span class="hljs-property">geometry</span>,
          <span class="hljs-attr">group</span>: glayer,
          <span class="hljs-attr">style</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">polys</span>.<span class="hljs-property">data</span>[l].<span class="hljs-property">style</span>,
          <span class="hljs-attr">type</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">polys</span>.<span class="hljs-property">data</span>[l].<span class="hljs-property">style</span>.<span class="hljs-property">type</span>
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">polys</span>.<span class="hljs-property">data</span>[l].<span class="hljs-property">style</span>.<span class="hljs-property">type</span>
            : <span class="hljs-string">"null"</span>,
          <span class="hljs-attr">path</span>: path,
          <span class="hljs-attr">filter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">polys</span>.<span class="hljs-property">data</span>[l].<span class="hljs-property">filter</span>
            ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">polys</span>.<span class="hljs-property">data</span>[l].<span class="hljs-property">filter</span>
            : { <span class="hljs-attr">show</span>: <span class="hljs-literal">false</span> }
        }).<span class="hljs-property">add</span>;
      }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">tiles</span>.<span class="hljs-property">show</span>) {
      <span class="hljs-keyword">let</span> filter = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">let</span> url = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">let</span> format = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">let</span> tiles = <span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">tiles</span>.<span class="hljs-property">data</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t <span class="hljs-keyword">in</span> tiles) {
        <span class="hljs-keyword">if</span> (tiles[t].<span class="hljs-property">show</span>) {
          <span class="hljs-keyword">let</span> raster = graster
            .<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"tiles-"</span> + uid + <span class="hljs-string">"-"</span> + tiles[t].<span class="hljs-property">id</span>);

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tiles[t].<span class="hljs-property">filter</span> !== <span class="hljs-literal">undefined</span>) {
            filter = tiles[t].<span class="hljs-property">filter</span>;
          }
          url = tiles[t].<span class="hljs-property">url</span> ? tiles[t].<span class="hljs-property">url</span> : <span class="hljs-literal">null</span>;
          format = tiles[t].<span class="hljs-property">format</span> ? tiles[t].<span class="hljs-property">format</span> : <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">let</span> zoom = tiles[t].<span class="hljs-property">zoom</span> ? tiles[t].<span class="hljs-property">zoom</span> : <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">let</span> tileset = <span class="hljs-title function_">getTiles</span>(tiles[t].<span class="hljs-property">type</span>, zoom, filter);
          <span class="hljs-keyword">let</span> slippy = <span class="hljs-title function_">geoTile</span>().<span class="hljs-title function_">size</span>([width, height]).<span class="hljs-title function_">tileSet</span>(tileset);

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tiles[t].<span class="hljs-property">delta</span> == <span class="hljs-string">"number"</span>) {
            slippy = <span class="hljs-title function_">geoTile</span>(tiles[t].<span class="hljs-property">delta</span>)
              .<span class="hljs-title function_">size</span>([width, height])
              .<span class="hljs-title function_">tileSet</span>(tileset);
          }

          slippy.<span class="hljs-title function_">projection</span>(projection);
          raster.<span class="hljs-title function_">call</span>(slippy.<span class="hljs-property">tile</span>);
        }
      }
      <span class="hljs-comment">//all the tile credit goes to Andrew Reid, 2018</span>
      <span class="hljs-keyword">function</span> <span class="hljs-title function_">getTiles</span>(<span class="hljs-params">type, zoom, filter</span>) {
        <span class="hljs-keyword">let</span> tileset = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"url"</span>) {
          tileset = {
            <span class="hljs-attr">type</span>: <span class="hljs-string">"tileset"</span>,
            <span class="hljs-attr">attribution</span>: <span class="hljs-string">""</span>,
            <span class="hljs-attr">source</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) {
              <span class="hljs-keyword">return</span> url + <span class="hljs-string">"/"</span> + d.<span class="hljs-property">z</span> + <span class="hljs-string">"/"</span> + d.<span class="hljs-property">x</span> + <span class="hljs-string">"/"</span> + d.<span class="hljs-property">y</span> + <span class="hljs-string">"."</span> + format;
            }
          };
        }
        <span class="hljs-keyword">if</span> (type.<span class="hljs-title function_">split</span>(<span class="hljs-string">"-"</span>)[<span class="hljs-number">0</span>] == <span class="hljs-string">"custom"</span>) {
          <span class="hljs-keyword">let</span> dir = type.<span class="hljs-title function_">split</span>(<span class="hljs-string">"-"</span>);
          dir = dir.<span class="hljs-title function_">join</span>(<span class="hljs-string">"/"</span>);
          <span class="hljs-comment">//console.log(dir);</span>
          tileset = {
            <span class="hljs-attr">type</span>: <span class="hljs-string">"tileset"</span>,
            <span class="hljs-attr">attribution</span>: <span class="hljs-string">""</span>,
            <span class="hljs-attr">source</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) {
              <span class="hljs-keyword">if</span> (zoom) {
                d.<span class="hljs-property">z</span> = zoom;
              } <span class="hljs-keyword">else</span> {
                d.<span class="hljs-property">z</span> = d.<span class="hljs-property">z</span>;
              }
              <span class="hljs-keyword">return</span> (
                <span class="hljs-string">"https://raw.githubusercontent.com/mbrickmaps/"</span> +
                dir.<span class="hljs-title function_">replace</span>(<span class="hljs-string">"custom"</span>, <span class="hljs-string">""</span>) +
                <span class="hljs-string">"/"</span> +
                d.<span class="hljs-property">z</span> +
                <span class="hljs-string">"/"</span> +
                d.<span class="hljs-property">x</span> +
                <span class="hljs-string">"/"</span> +
                ((<span class="hljs-number">1</span> &lt;&lt; d.<span class="hljs-property">z</span>) - d.<span class="hljs-property">y</span> - <span class="hljs-number">1</span>) +
                <span class="hljs-string">".png"</span>
              );
            }
          };
        }
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"debug"</span>) {
          tileset = {
            <span class="hljs-attr">source</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-string">`https://dummyimage.com/256x256/a8a8a8/0011ff.png&amp;text=<span class="hljs-subst">${
                d.z
              }</span>/<span class="hljs-subst">${d.x}</span>/<span class="hljs-subst">${(<span class="hljs-number">1</span> &lt;&lt; d.z) - d.y - <span class="hljs-number">1</span>}</span>`</span>;
            }
          };
        }
        <span class="hljs-keyword">return</span> tileset;
      }
      <span class="hljs-keyword">function</span> <span class="hljs-title function_">geoTile</span>(<span class="hljs-params">delta</span>) {
        <span class="hljs-keyword">const</span> tau = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>;
        <span class="hljs-keyword">var</span> lim = <span class="hljs-number">85.05113</span>;
        <span class="hljs-keyword">var</span> tileSize = <span class="hljs-number">256</span>;

        <span class="hljs-keyword">var</span> w = width;
        <span class="hljs-keyword">var</span> h = height;

        <span class="hljs-keyword">var</span> pk = w / tau;
        <span class="hljs-keyword">var</span> pc = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
        <span class="hljs-keyword">var</span> pr = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">var</span> tk = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">var</span> tx = w / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">var</span> ty = h / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">var</span> p = d3.<span class="hljs-title function_">geoMercator</span>().<span class="hljs-title function_">scale</span>(pk).<span class="hljs-title function_">center</span>(pc);

        <span class="hljs-keyword">var</span> z0 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> z1 = <span class="hljs-number">15</span>;
        <span class="hljs-keyword">var</span> extent = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          <span class="hljs-keyword">return</span> { <span class="hljs-attr">left</span>: -<span class="hljs-number">179.99999</span>, <span class="hljs-attr">top</span>: lim, <span class="hljs-attr">right</span>: <span class="hljs-number">179.9999</span>, <span class="hljs-attr">bottom</span>: -lim };
        };
        <span class="hljs-keyword">var</span> wrap = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">var</span> tileWidth = <span class="hljs-number">256</span>;
        <span class="hljs-keyword">var</span> tileHeight = <span class="hljs-number">256</span>;
        <span class="hljs-keyword">var</span> xyz = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">var</span> source = <span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) {
          <span class="hljs-keyword">return</span> (
            <span class="hljs-string">"http://"</span> +
            <span class="hljs-string">"abc"</span>[d.<span class="hljs-property">y</span> % <span class="hljs-number">3</span>] +
            <span class="hljs-string">".tile.openstreetmap.org/"</span> +
            d.<span class="hljs-property">z</span> +
            <span class="hljs-string">"/"</span> +
            d.<span class="hljs-property">x</span> +
            <span class="hljs-string">"/"</span> +
            d.<span class="hljs-property">y</span> +
            <span class="hljs-string">".png"</span>
          );
        };
        <span class="hljs-keyword">var</span> a = <span class="hljs-string">"Tiles © OpenStreetMap contributors"</span>;
        geoTile.<span class="hljs-property">xyz</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> ? ((xyz = _), geoTile) : xyz;
        };

        <span class="hljs-keyword">function</span> <span class="hljs-title function_">geoTile</span>(<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">p</span>(_);
        }

        geoTile.<span class="hljs-property">width</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> ? ((w = _), geoTile) : w;
        };
        geoTile.<span class="hljs-property">height</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> ? ((h = _), geoTile) : h;
        };
        geoTile.<span class="hljs-property">size</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>) {
            _ <span class="hljs-keyword">instanceof</span> d3.<span class="hljs-property">selection</span>
              ? ((w = _.<span class="hljs-title function_">attr</span>(<span class="hljs-string">"width"</span>)),
                (h = _.<span class="hljs-title function_">attr</span>(<span class="hljs-string">"height"</span>)),
                (tx = w / <span class="hljs-number">2</span>),
                (ty = h / <span class="hljs-number">2</span>))
              : ((w = _[<span class="hljs-number">0</span>]), (h = _[<span class="hljs-number">1</span>]));
            <span class="hljs-keyword">return</span> geoTile;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> [w, h];
        };
        geoTile.<span class="hljs-property">source</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> ? ((source = _), geoTile) : source;
        };
        geoTile.<span class="hljs-property">projection</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>
            ? ((p = _), (pk = _.<span class="hljs-title function_">scale</span>()), (pc = _.<span class="hljs-title function_">center</span>()), geoTile)
            : p;
        };
        geoTile.<span class="hljs-property">attribution</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> ? ((a = _), geoTile) : a;
        };
        geoTile.<span class="hljs-property">wrap</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> ? ((wrap = _), geoTile) : wrap;
        };
        geoTile.<span class="hljs-property">tileWidth</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {};
        geoTile.<span class="hljs-property">tileHeight</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {};

        geoTile.<span class="hljs-property">invert</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">return</span> p.<span class="hljs-title function_">invert</span>(_);
        };
        geoTile.<span class="hljs-property">center</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">var</span> rotate = d3.<span class="hljs-title function_">geoRotation</span>(p.<span class="hljs-title function_">rotate</span>());
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>) {
            pc = <span class="hljs-title function_">rotate</span>(_);
            p.<span class="hljs-title function_">center</span>(pc);
            <span class="hljs-keyword">return</span> geoTile;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> rotate.<span class="hljs-title function_">invert</span>(pc);
          }
        };
        geoTile.<span class="hljs-property">scale</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> ? ((pk = _), p.<span class="hljs-title function_">scale</span>(pk), geoTile) : pk;
        };
        geoTile.<span class="hljs-property">rotate</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> ? ((pr = _), p.<span class="hljs-title function_">rotate</span>([pr, <span class="hljs-number">0</span>]), geoTile) : pr;
        };
        geoTile.<span class="hljs-property">fit</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>
            ? (p.<span class="hljs-title function_">fitSize</span>([w, h], _),
              (tx = p.<span class="hljs-title function_">translate</span>()[<span class="hljs-number">0</span>]),
              (ty = p.<span class="hljs-title function_">translate</span>()[<span class="hljs-number">1</span>]),
              (pk = p.<span class="hljs-title function_">scale</span>()),
              geoTile)
            : <span class="hljs-string">"n/a"</span>;
        };
        geoTile.<span class="hljs-property">fitMargin</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">m, f</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>
            ? (p.<span class="hljs-title function_">fitExtent</span>(
                [
                  [m, m],
                  [w - m, h - m]
                ],
                f
              ),
              (tx = p.<span class="hljs-title function_">translate</span>()[<span class="hljs-number">0</span>]),
              (ty = p.<span class="hljs-title function_">translate</span>()[<span class="hljs-number">1</span>]),
              (pk = p.<span class="hljs-title function_">scale</span>()),
              geoTile)
            : <span class="hljs-string">"n/a"</span>;
        };

        geoTile.<span class="hljs-property">zoomScale</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> ? ((tk = _), p.<span class="hljs-title function_">scale</span>(pk * tk), geoTile) : tk;
        };
        geoTile.<span class="hljs-property">zoomTranslate</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>
            ? ((tx = _[<span class="hljs-number">0</span>]), (ty = _[<span class="hljs-number">1</span>]), p.<span class="hljs-title function_">translate</span>([tx, ty]), geoTile)
            : [tx, ty];
        };
        geoTile.<span class="hljs-property">zoomIdentity</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          <span class="hljs-keyword">return</span> d3.<span class="hljs-property">zoomIdentity</span>.<span class="hljs-title function_">translate</span>(tx, ty).<span class="hljs-title function_">scale</span>(tk).<span class="hljs-title function_">translate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        };
        geoTile.<span class="hljs-property">zoomTransform</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) {
          <span class="hljs-keyword">return</span> (
            (tx = t.<span class="hljs-property">x</span>),
            (ty = t.<span class="hljs-property">y</span>),
            (tk = t.<span class="hljs-property">k</span>),
            p.<span class="hljs-title function_">translate</span>([tx, ty]),
            p.<span class="hljs-title function_">scale</span>(pk * tk),
            geoTile
          );
        };

        geoTile.<span class="hljs-property">tileDepth</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          <span class="hljs-keyword">var</span> a = [w / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, h / <span class="hljs-number">2</span>];
          <span class="hljs-keyword">var</span> b = [w / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, h / <span class="hljs-number">2</span>];
          <span class="hljs-keyword">var</span> dx = d3.<span class="hljs-title function_">geoDistance</span>(p.<span class="hljs-title function_">invert</span>(a), p.<span class="hljs-title function_">invert</span>(b));
          <span class="hljs-keyword">var</span> scale = ((<span class="hljs-number">20</span> / dx) * tk * pk) / <span class="hljs-number">200</span>;
          <span class="hljs-keyword">var</span> z = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(scale) / <span class="hljs-title class_">Math</span>.<span class="hljs-property">LN2</span> - <span class="hljs-number">8</span>, <span class="hljs-number">2</span>);
          z = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(z, <span class="hljs-number">15</span>) | <span class="hljs-number">0</span>;
          <span class="hljs-keyword">var</span> maxTiles = (w * h) / <span class="hljs-number">256</span> / <span class="hljs-number">128</span>;

          <span class="hljs-keyword">while</span> (<span class="hljs-title function_">d3quadTiles</span>(p, z).<span class="hljs-property">length</span> &gt; maxTiles) {
            z--;
          }

          <span class="hljs-keyword">if</span> (delta) {
            z = z + delta;
          }
          <span class="hljs-keyword">return</span> z;
        };
        geoTile.<span class="hljs-property">zoomTranslateExtent</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">var</span> e = <span class="hljs-title function_">extent</span>();
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>) {
            e.<span class="hljs-property">left</span> = _[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
            e.<span class="hljs-property">top</span> = _[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];
            e.<span class="hljs-property">right</span> = _[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
            e.<span class="hljs-property">bottom</span> = _[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];
            <span class="hljs-keyword">return</span> geoTile;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> x0 = <span class="hljs-title function_">p</span>([e.<span class="hljs-property">left</span> - pr, e.<span class="hljs-property">top</span>])[<span class="hljs-number">0</span>] - tx;
            <span class="hljs-keyword">var</span> y0 = <span class="hljs-title function_">p</span>([e.<span class="hljs-property">left</span> - pr, e.<span class="hljs-property">top</span>])[<span class="hljs-number">1</span>] - ty;
            <span class="hljs-keyword">var</span> x1 = <span class="hljs-title function_">p</span>([e.<span class="hljs-property">right</span> - pr, e.<span class="hljs-property">bottom</span>])[<span class="hljs-number">0</span>] - tx;
            <span class="hljs-keyword">var</span> y1 = <span class="hljs-title function_">p</span>([e.<span class="hljs-property">right</span> - pr, e.<span class="hljs-property">bottom</span>])[<span class="hljs-number">1</span>] - ty;
            <span class="hljs-keyword">return</span> [
              [x0, y0],
              [x1, y1]
            ];
          }
        };
        geoTile.<span class="hljs-property">zoomTranslateConstrain</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          <span class="hljs-keyword">var</span> e = <span class="hljs-title function_">extent</span>();
          e.<span class="hljs-property">left</span> = p.<span class="hljs-title function_">invert</span>([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>])[<span class="hljs-number">0</span>];
          e.<span class="hljs-property">top</span> = p.<span class="hljs-title function_">invert</span>([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>])[<span class="hljs-number">1</span>];
          e.<span class="hljs-property">right</span> = p.<span class="hljs-title function_">invert</span>([w, h])[<span class="hljs-number">0</span>];
          e.<span class="hljs-property">bottom</span> = p.<span class="hljs-title function_">invert</span>([w, h])[<span class="hljs-number">1</span>];

          <span class="hljs-keyword">var</span> x0 = <span class="hljs-title function_">p</span>([e.<span class="hljs-property">left</span> - pr, e.<span class="hljs-property">top</span>])[<span class="hljs-number">0</span>] - tx;
          <span class="hljs-keyword">var</span> y0 = <span class="hljs-title function_">p</span>([e.<span class="hljs-property">left</span> - pr, e.<span class="hljs-property">top</span>])[<span class="hljs-number">1</span>] - ty;
          <span class="hljs-keyword">var</span> x1 = <span class="hljs-title function_">p</span>([e.<span class="hljs-property">right</span> - pr, e.<span class="hljs-property">bottom</span>])[<span class="hljs-number">0</span>] - tx;
          <span class="hljs-keyword">var</span> y1 = <span class="hljs-title function_">p</span>([e.<span class="hljs-property">right</span> - pr, e.<span class="hljs-property">bottom</span>])[<span class="hljs-number">1</span>] - ty;
          <span class="hljs-keyword">return</span> [
            [x0, y0],
            [x1, y1]
          ];
        };

        geoTile.<span class="hljs-property">tiles</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          <span class="hljs-keyword">var</span> z = geoTile.<span class="hljs-title function_">tileDepth</span>();
          <span class="hljs-comment">// var e = p.clipExtent();</span>
          <span class="hljs-keyword">var</span> set = <span class="hljs-title function_">d3quadTiles</span>(p, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(z0, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(z, z1)));
          <span class="hljs-comment">//p.clipExtent(e);</span>

          <span class="hljs-keyword">return</span> set;
        };
        geoTile.<span class="hljs-property">tile</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">g</span>) {
          <span class="hljs-keyword">let</span> uid = g.<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">"-"</span>)[<span class="hljs-number">1</span>];
          <span class="hljs-keyword">let</span> type = g.<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">"-"</span>)[<span class="hljs-number">2</span>];

          <span class="hljs-keyword">var</span> path = d3.<span class="hljs-title function_">geoPath</span>(p);

          <span class="hljs-keyword">var</span> tile = g.<span class="hljs-title function_">selectAll</span>(<span class="hljs-string">"tiles"</span>).<span class="hljs-title function_">data</span>(geoTile.<span class="hljs-title function_">tiles</span>());

          <span class="hljs-keyword">var</span> enter = tile
            .<span class="hljs-title function_">enter</span>()
            .<span class="hljs-title function_">append</span>(<span class="hljs-string">"image"</span>)
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"class"</span>, <span class="hljs-string">"tile"</span>)
            .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-string">"tile-"</span> + type + <span class="hljs-string">"-"</span> + uid + <span class="hljs-string">"-"</span> + d.<span class="hljs-property">key</span>.<span class="hljs-title function_">join</span>(<span class="hljs-string">"-"</span>);
            })
            .<span class="hljs-title function_">each</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) {
              <span class="hljs-keyword">var</span> k = d.<span class="hljs-property">key</span>;
              <span class="hljs-keyword">var</span> that = <span class="hljs-variable language_">this</span>;
              d.<span class="hljs-property">image</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();
              d.<span class="hljs-property">image</span>.<span class="hljs-property">crossOrigin</span> = <span class="hljs-literal">true</span>;
              <span class="hljs-keyword">var</span> location = { <span class="hljs-attr">x</span>: k[<span class="hljs-number">0</span>], <span class="hljs-attr">y</span>: k[<span class="hljs-number">1</span>], <span class="hljs-attr">z</span>: k[<span class="hljs-number">2</span>] };
              d.<span class="hljs-property">image</span>.<span class="hljs-property">src</span> = <span class="hljs-title function_">source</span>(location);
              d.<span class="hljs-property">image</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
                <span class="hljs-title function_">onload</span>(d, that);
              };
            });

          <span class="hljs-keyword">function</span> <span class="hljs-title function_">onload</span>(<span class="hljs-params">d, that</span>) {
            <span class="hljs-keyword">var</span> mercatorCanvas = d3
              .<span class="hljs-title function_">create</span>(<span class="hljs-string">"canvas"</span>)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"width"</span>, tileWidth)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"height"</span>, tileHeight);

            <span class="hljs-keyword">var</span> mercatorContext = mercatorCanvas.<span class="hljs-title function_">node</span>().<span class="hljs-title function_">getContext</span>(<span class="hljs-string">"2d"</span>);
            mercatorContext.<span class="hljs-title function_">drawImage</span>(d.<span class="hljs-property">image</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, tileWidth, tileHeight);

            <span class="hljs-keyword">var</span> k = d.<span class="hljs-property">key</span>;
            <span class="hljs-keyword">var</span> tilesAcross = <span class="hljs-number">1</span> &lt;&lt; k[<span class="hljs-number">2</span>];

            <span class="hljs-keyword">var</span> webMercator = d3
              .<span class="hljs-title function_">geoMercator</span>()
              .<span class="hljs-title function_">scale</span>(tilesAcross / <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">2</span>)
              .<span class="hljs-title function_">translate</span>([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>])
              .<span class="hljs-title function_">center</span>([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]);

            <span class="hljs-keyword">var</span> reprojectedTileBounds = path.<span class="hljs-title function_">bounds</span>(d),
              x0 = reprojectedTileBounds[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] | <span class="hljs-number">0</span>,
              y0 = reprojectedTileBounds[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] | <span class="hljs-number">0</span>,
              x1 = (reprojectedTileBounds[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) | <span class="hljs-number">0</span>,
              y1 = (reprojectedTileBounds[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) | <span class="hljs-number">0</span>;

            <span class="hljs-keyword">var</span> λ<span class="hljs-number">0</span> = (k[<span class="hljs-number">0</span>] / tilesAcross) * <span class="hljs-number">360</span> - <span class="hljs-number">180</span>,
              λ<span class="hljs-number">1</span> = ((k[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) / tilesAcross) * <span class="hljs-number">360</span> - <span class="hljs-number">180</span>,
              φ<span class="hljs-number">1</span> = webMercator.<span class="hljs-title function_">invert</span>([<span class="hljs-number">0</span>, k[<span class="hljs-number">1</span>] - tilesAcross / <span class="hljs-number">2</span>])[<span class="hljs-number">1</span>],
              φ<span class="hljs-number">0</span> = webMercator.<span class="hljs-title function_">invert</span>([<span class="hljs-number">0</span>, k[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> - tilesAcross / <span class="hljs-number">2</span>])[<span class="hljs-number">1</span>];

            <span class="hljs-keyword">var</span> newCanvas = d3.<span class="hljs-title function_">create</span>(<span class="hljs-string">"canvas"</span>).<span class="hljs-title function_">node</span>();

            (newCanvas.<span class="hljs-property">width</span> = x1 - x0), (newCanvas.<span class="hljs-property">height</span> = y1 - y0);
            <span class="hljs-keyword">var</span> newContext = newCanvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">"2d"</span>);

            <span class="hljs-keyword">if</span> (newCanvas.<span class="hljs-property">width</span> &gt; <span class="hljs-number">0</span> &amp;&amp; newCanvas.<span class="hljs-property">height</span> &gt; <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">var</span> sourceData = mercatorContext.<span class="hljs-title function_">getImageData</span>(
                  <span class="hljs-number">0</span>,
                  <span class="hljs-number">0</span>,
                  tileWidth,
                  tileHeight
                ).<span class="hljs-property">data</span>,
                target = newContext.<span class="hljs-title function_">createImageData</span>(
                  newCanvas.<span class="hljs-property">width</span>,
                  newCanvas.<span class="hljs-property">height</span>
                ),
                targetData = target.<span class="hljs-property">data</span>;

              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y = y0, i = -<span class="hljs-number">1</span>; y &lt; y1; ++y) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x = x0; x &lt; x1; ++x) {
                  <span class="hljs-keyword">var</span> pt = p.<span class="hljs-title function_">invert</span>([x, y]),
                    λ = pt[<span class="hljs-number">0</span>],
                    φ = pt[<span class="hljs-number">1</span>];

                  <span class="hljs-keyword">if</span> (λ &gt; λ<span class="hljs-number">1</span> || λ &lt; λ<span class="hljs-number">0</span> || φ &gt; φ<span class="hljs-number">1</span> || φ &lt; φ<span class="hljs-number">0</span>) {
                    i += <span class="hljs-number">4</span>;
                    targetData[i] = <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">continue</span>;
                  }
                  <span class="hljs-keyword">var</span> top =
                    ((((tilesAcross + <span class="hljs-title function_">webMercator</span>([<span class="hljs-number">0</span>, φ])[<span class="hljs-number">1</span>]) * tileHeight) |
                      <span class="hljs-number">0</span>) %
                      <span class="hljs-number">256</span> |
                      <span class="hljs-number">0</span>) *
                    tileWidth;
                  <span class="hljs-keyword">var</span> q =
                    (((((λ - λ<span class="hljs-number">0</span>) / (λ<span class="hljs-number">1</span> - λ<span class="hljs-number">0</span>)) * tileWidth) | <span class="hljs-number">0</span>) + top) * <span class="hljs-number">4</span>;

                  <span class="hljs-keyword">let</span> r = sourceData[q];
                  <span class="hljs-keyword">let</span> g = sourceData[++q];
                  <span class="hljs-keyword">let</span> b = sourceData[++q];
                  <span class="hljs-keyword">let</span> a = <span class="hljs-number">255</span>;

                  targetData[++i] = r;
                  targetData[++i] = g;
                  targetData[++i] = b;
                  targetData[++i] = a;
                }
              }

              <span class="hljs-keyword">if</span> (target) newContext.<span class="hljs-title function_">putImageData</span>(target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
            }

            d3.<span class="hljs-title function_">select</span>(<span class="hljs-string">"#"</span> + d3.<span class="hljs-title function_">select</span>(that).<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>))
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"xlink:href"</span>, newCanvas.<span class="hljs-title function_">toDataURL</span>())
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"x"</span>, x0)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"width"</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(newCanvas.<span class="hljs-property">width</span>) + <span class="hljs-number">1</span>)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"height"</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(newCanvas.<span class="hljs-property">height</span>) + <span class="hljs-number">1</span>)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"y"</span>, y0);
          }
        };

        geoTile.<span class="hljs-property">tileSet</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">_</span>) {
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>) {
            a = _.<span class="hljs-property">attribution</span> ? _.<span class="hljs-property">attribution</span> : <span class="hljs-string">"Unknown"</span>;
            source = _.<span class="hljs-property">source</span>
              ? _.<span class="hljs-property">source</span>
              : (<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"no source provided, using osm"</span>),
                (a = <span class="hljs-string">"Tiles © OpenStreetMap contributors"</span>),
                <span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) {
                  <span class="hljs-keyword">return</span> (
                    <span class="hljs-string">"http://"</span> +
                    <span class="hljs-string">"abc"</span>[d.<span class="hljs-property">y</span> % <span class="hljs-number">3</span>] +
                    <span class="hljs-string">".tile.openstreetmap.org/"</span> +
                    d.<span class="hljs-property">z</span> +
                    <span class="hljs-string">"/"</span> +
                    d.<span class="hljs-property">x</span> +
                    <span class="hljs-string">"/"</span> +
                    d.<span class="hljs-property">y</span> +
                    <span class="hljs-string">".png"</span>
                  );
                });
            lim = _.<span class="hljs-property">limit</span> ? _.<span class="hljs-property">limit</span> : <span class="hljs-number">85.05113</span>;
            tileSize = _.<span class="hljs-property">tileSize</span> ? _.<span class="hljs-property">tileSize</span> : <span class="hljs-number">256</span>;
            z0 = _.<span class="hljs-property">minDepth</span> ? _.<span class="hljs-property">minDepth</span> : <span class="hljs-number">1</span>;
            z1 = _.<span class="hljs-property">maxDepth</span> ? _.<span class="hljs-property">maxDepth</span> : <span class="hljs-number">13</span>;
            wrap = _.<span class="hljs-property">wrap</span> ? _.<span class="hljs-property">wrap</span> : <span class="hljs-literal">false</span>;
            xyz = _.<span class="hljs-property">xyz</span> ? _.<span class="hljs-property">xyz</span> : <span class="hljs-literal">true</span>;
          }
          <span class="hljs-keyword">return</span> geoTile;
        };
        <span class="hljs-keyword">return</span> geoTile;
      }
      <span class="hljs-keyword">function</span> <span class="hljs-title function_">d3quadTiles</span>(<span class="hljs-params">projection, zoom</span>) {
        <span class="hljs-keyword">var</span> tiles = [],
          width = <span class="hljs-number">1</span> &lt;&lt; (zoom = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, zoom)),
          step = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0.2</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>, zoom * <span class="hljs-number">0.01</span>)),
          invisible,
          precision = projection.<span class="hljs-title function_">precision</span>(),
          stream = projection.<span class="hljs-title function_">precision</span>(<span class="hljs-number">960</span>).<span class="hljs-title function_">stream</span>({
            <span class="hljs-attr">point</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
              invisible = <span class="hljs-literal">false</span>;
            },
            <span class="hljs-attr">lineStart</span>: noop,
            <span class="hljs-attr">lineEnd</span>: noop,
            <span class="hljs-attr">polygonStart</span>: noop,
            <span class="hljs-attr">polygonEnd</span>: noop
          });

        <span class="hljs-title function_">visit</span>(-<span class="hljs-number">180</span>, -<span class="hljs-number">180</span>, <span class="hljs-number">180</span>, <span class="hljs-number">180</span>);

        projection.<span class="hljs-title function_">precision</span>(precision);

        <span class="hljs-keyword">return</span> tiles;

        <span class="hljs-keyword">function</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">x1, y1, x2, y2</span>) {
          <span class="hljs-keyword">var</span> w = x2 - x1,
            m1 = mercatorφ(y1),
            m2 = mercatorφ(y2),
            δ = step * w;
          invisible = <span class="hljs-literal">true</span>;
          stream.<span class="hljs-title function_">polygonStart</span>(), stream.<span class="hljs-title function_">lineStart</span>();
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x = x1; x &lt; x2 + δ / <span class="hljs-number">2</span> &amp;&amp; invisible; x += δ)
            stream.<span class="hljs-title function_">point</span>(x, m1);
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y = m1; (y += δ) &lt; m2 &amp;&amp; invisible; ) stream.<span class="hljs-title function_">point</span>(x2, y);
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x = x2; x &gt; x1 - δ / <span class="hljs-number">2</span> &amp;&amp; invisible; x -= δ)
            stream.<span class="hljs-title function_">point</span>(x, m2);
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y = m2; (y -= δ) &gt; m1 &amp;&amp; invisible; ) stream.<span class="hljs-title function_">point</span>(x1, y);
          <span class="hljs-keyword">if</span> (invisible) stream.<span class="hljs-title function_">point</span>(x1, m1);
          stream.<span class="hljs-title function_">lineEnd</span>(), stream.<span class="hljs-title function_">polygonEnd</span>();
          <span class="hljs-keyword">if</span> (w &lt;= <span class="hljs-number">360</span> / width) {
            <span class="hljs-keyword">if</span> (!invisible) {
              tiles.<span class="hljs-title function_">push</span>({
                <span class="hljs-attr">type</span>: <span class="hljs-string">"Polygon"</span>,
                <span class="hljs-attr">coordinates</span>: [
                  d3
                    .<span class="hljs-title function_">range</span>(x1, x2 + δ / <span class="hljs-number">2</span>, δ)
                    .<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {
                      <span class="hljs-keyword">return</span> [x, y1];
                    })
                    .<span class="hljs-title function_">concat</span>([[x2, <span class="hljs-number">0.5</span> * (y1 + y2)]])
                    .<span class="hljs-title function_">concat</span>(
                      d3.<span class="hljs-title function_">range</span>(x2, x1 - δ / <span class="hljs-number">2</span>, -δ).<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {
                        <span class="hljs-keyword">return</span> [x, y2];
                      })
                    )
                    .<span class="hljs-title function_">concat</span>([[x1, <span class="hljs-number">0.5</span> * (y1 + y2)]])
                    .<span class="hljs-title function_">concat</span>([[x1, y1]])
                    .<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) {
                      <span class="hljs-keyword">return</span> [d[<span class="hljs-number">0</span>], mercatorφ(d[<span class="hljs-number">1</span>])];
                    })
                ],
                <span class="hljs-attr">key</span>: [
                  (((<span class="hljs-number">180</span> + x1) / <span class="hljs-number">360</span>) * width) | <span class="hljs-number">0</span>,
                  (((<span class="hljs-number">180</span> + y1) / <span class="hljs-number">360</span>) * width) | <span class="hljs-number">0</span>,
                  zoom
                ],
                <span class="hljs-attr">centroid</span>: [<span class="hljs-number">0.5</span> * (x1 + x2), <span class="hljs-number">0.5</span> * (m1 + m2)]
              });
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!invisible) {
            <span class="hljs-keyword">var</span> x = <span class="hljs-number">0.5</span> * (x1 + x2),
              y = <span class="hljs-number">0.5</span> * (y1 + y2);
            <span class="hljs-title function_">visit</span>(x1, y1, x, y);
            <span class="hljs-title function_">visit</span>(x, y1, x2, y);
            <span class="hljs-title function_">visit</span>(x1, y, x, y2);
            <span class="hljs-title function_">visit</span>(x, y, x2, y2);
          }
        }
      }
      <span class="hljs-keyword">function</span> mercatorφ(y) {
        <span class="hljs-keyword">return</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">atan</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">exp</span>((-y * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) / <span class="hljs-number">180</span>)) * <span class="hljs-number">360</span>) / <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> - <span class="hljs-number">90</span>;
      }
      <span class="hljs-keyword">function</span> <span class="hljs-title function_">noop</span>(<span class="hljs-params"></span>) {}
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">grids</span>.<span class="hljs-property">show</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">grids</span>.<span class="hljs-property">data</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"show grid"</span>);
        <span class="hljs-keyword">let</span> grids = <span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">grids</span>;
        <span class="hljs-title function_">addGrid</span>(grids, width / grids.<span class="hljs-property">size</span>, grids.<span class="hljs-property">data</span>);
      }
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">addQtree</span>(<span class="hljs-params">grids, data</span>) {
      <span class="hljs-keyword">let</span> pointsRaw = data.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> <span class="hljs-title function_">projection</span>(d.<span class="hljs-property">geometry</span>.<span class="hljs-property">coordinates</span>));

      <span class="hljs-keyword">let</span> quadtree = d3
        .<span class="hljs-title function_">quadtree</span>()
        .<span class="hljs-title function_">extent</span>([
          [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>],
          [width + <span class="hljs-number">1</span>, height + <span class="hljs-number">1</span>]
        ])
        .<span class="hljs-title function_">addAll</span>(pointsRaw);

      <span class="hljs-keyword">function</span> <span class="hljs-title function_">filterByAttribute</span>(<span class="hljs-params">attribute, value</span>) {
        <span class="hljs-keyword">const</span> filteredPoints = [];
        quadtree.<span class="hljs-title function_">visit</span>(<span class="hljs-function">(<span class="hljs-params">node, x0, y0, x1, y1</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (node.<span class="hljs-property">length</span>) {
            <span class="hljs-comment">// if it's an internal node</span>
            <span class="hljs-keyword">const</span> children = node.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// get the child nodes</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> children) {
              <span class="hljs-keyword">if</span> (child) {
                <span class="hljs-comment">// if the child exists</span>
                child.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> {
                  <span class="hljs-keyword">if</span> (d[attribute] === value) {
                    <span class="hljs-comment">// check if the attribute matches the desired value</span>
                    filteredPoints.<span class="hljs-title function_">push</span>(d); <span class="hljs-comment">// add the point to the filtered array</span>
                  }
                });
              }
            }
          }
        });
        <span class="hljs-keyword">return</span> filteredPoints;
      }

      <span class="hljs-keyword">if</span> (grids.<span class="hljs-property">type</span> == <span class="hljs-string">"byAttribute"</span>) {
        <span class="hljs-keyword">let</span> groupedData = d3.<span class="hljs-title function_">group</span>(
          data,
          <span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> d.<span class="hljs-property">properties</span>.<span class="hljs-property">data</span>[grids.<span class="hljs-property">method</span>.<span class="hljs-property">groupBy</span>]
        );
        <span class="hljs-keyword">let</span> attributeValues = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(groupedData.<span class="hljs-title function_">keys</span>());
        <span class="hljs-keyword">let</span> filteredData = attributeValues.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">group</span>: value,
            <span class="hljs-attr">geom</span>: groupedData.<span class="hljs-title function_">get</span>(value)
          };
        });
        filteredData.<span class="hljs-property">total</span> = filteredData
          .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> d.<span class="hljs-property">geom</span>.<span class="hljs-property">length</span>)
          .<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, a</span>) =&gt;</span> sum + a, <span class="hljs-number">0</span>);
      }

      <span class="hljs-keyword">function</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">quadtree, xmin, ymin, xmax, ymax</span>) {
        <span class="hljs-keyword">const</span> results = [];
        quadtree.<span class="hljs-title function_">visit</span>(<span class="hljs-function">(<span class="hljs-params">node, x1, y1, x2, y2</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (!node.<span class="hljs-property">length</span>) {
            <span class="hljs-keyword">do</span> {
              <span class="hljs-keyword">let</span> d = node.<span class="hljs-property">data</span>;
              <span class="hljs-keyword">if</span> (d[<span class="hljs-number">0</span>] &gt;= xmin &amp;&amp; d[<span class="hljs-number">0</span>] &lt; xmax &amp;&amp; d[<span class="hljs-number">1</span>] &gt;= ymin &amp;&amp; d[<span class="hljs-number">1</span>] &lt; ymax) {
                results.<span class="hljs-title function_">push</span>(d);
              }
            } <span class="hljs-keyword">while</span> ((node = node.<span class="hljs-property">next</span>));
          }
          <span class="hljs-keyword">return</span> x1 &gt;= xmax || y1 &gt;= ymax || x2 &lt; xmin || y2 &lt; ymin;
        });
        <span class="hljs-keyword">return</span> results;
      }

      <span class="hljs-keyword">let</span> clusterPoints = [];
      <span class="hljs-keyword">let</span> clusterRange = width / grids.<span class="hljs-property">size</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>; x &lt;= width; x += clusterRange) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>; y &lt;= height; y += clusterRange) {
          <span class="hljs-keyword">let</span> searched = <span class="hljs-title function_">search</span>(
            quadtree,
            x,
            y,
            x + clusterRange,
            y + clusterRange
          );
          <span class="hljs-keyword">let</span> centerPoint = searched.<span class="hljs-title function_">reduce</span>(
            <span class="hljs-keyword">function</span> (<span class="hljs-params">prev, current</span>) {
              <span class="hljs-keyword">return</span> [prev[<span class="hljs-number">0</span>] + current[<span class="hljs-number">0</span>], prev[<span class="hljs-number">1</span>] + current[<span class="hljs-number">1</span>]];
            },
            [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
          );

          centerPoint[<span class="hljs-number">0</span>] = centerPoint[<span class="hljs-number">0</span>] / searched.<span class="hljs-property">length</span>;
          centerPoint[<span class="hljs-number">1</span>] = centerPoint[<span class="hljs-number">1</span>] / searched.<span class="hljs-property">length</span>;
          centerPoint.<span class="hljs-title function_">push</span>(searched);
          <span class="hljs-keyword">if</span> (centerPoint[<span class="hljs-number">0</span>] &amp;&amp; centerPoint[<span class="hljs-number">1</span>]) {
            <span class="hljs-keyword">if</span> (grids.<span class="hljs-property">method</span>.<span class="hljs-property">type</span> == <span class="hljs-string">"raw"</span>) {
              clusterPoints.<span class="hljs-title function_">push</span>(
                turf.<span class="hljs-title function_">point</span>(
                  projection.<span class="hljs-title function_">invert</span>([centerPoint[<span class="hljs-number">0</span>], centerPoint[<span class="hljs-number">1</span>]]),
                  {
                    <span class="hljs-attr">count</span>: searched.<span class="hljs-property">length</span>
                  }
                )
              );
            } <span class="hljs-keyword">else</span> {
            }
          } <span class="hljs-keyword">else</span> {
          }
        }
      }

      <span class="hljs-keyword">let</span> pScale = d3
        .<span class="hljs-title function_">scaleSqrt</span>()
        .<span class="hljs-title function_">domain</span>([
          d3.<span class="hljs-title function_">min</span>(clusterPoints, <span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> d.<span class="hljs-property">properties</span>.<span class="hljs-property">count</span>),
          d3.<span class="hljs-title function_">max</span>(clusterPoints, <span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> d.<span class="hljs-property">properties</span>.<span class="hljs-property">count</span>)
        ])
        .<span class="hljs-title function_">rangeRound</span>([grids.<span class="hljs-property">minSize</span>, grids.<span class="hljs-property">maxSize</span>]);
      <span class="hljs-keyword">if</span> (grids.<span class="hljs-property">square</span>.<span class="hljs-property">show</span> == <span class="hljs-literal">false</span>) {
        ggrid.<span class="hljs-title function_">remove</span>();
      }
      <span class="hljs-keyword">if</span> (grids.<span class="hljs-property">qtree</span>.<span class="hljs-property">show</span> == <span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">materialize</span>(<span class="hljs-params">quadtree</span>) {
          <span class="hljs-keyword">const</span> rects = [];
        }
      }
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Layer</span>({
        <span class="hljs-attr">geometry</span>: clusterPoints,
        <span class="hljs-attr">group</span>: glayer,
        <span class="hljs-attr">path</span>: path,
        <span class="hljs-attr">type</span>: grids.<span class="hljs-property">type</span>,
        <span class="hljs-attr">shape</span>: grids.<span class="hljs-property">shape</span>,
        <span class="hljs-attr">style</span>: grids.<span class="hljs-property">style</span>,
        <span class="hljs-attr">scale</span>: pScale <span class="hljs-comment">//grids.scale</span>
      }).<span class="hljs-property">add</span>;
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">addGrid</span>(<span class="hljs-params">grids, units, data</span>) {
      <span class="hljs-keyword">if</span> (grids.<span class="hljs-property">type</span> == <span class="hljs-string">"qtree"</span> || grids.<span class="hljs-property">type</span> == <span class="hljs-string">"byAttribute"</span>) {
        <span class="hljs-keyword">var</span> clusterPoints = [];
        <span class="hljs-keyword">var</span> clusterRange = units;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>; x &lt;= width; x += clusterRange) {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span>; y &lt;= height; y += clusterRange) {
            ggrid
              .<span class="hljs-title function_">append</span>(<span class="hljs-string">"rect"</span>)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"x"</span>, x)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"y"</span>, y)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"width"</span>, clusterRange)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"height"</span>, clusterRange)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"class"</span>, <span class="hljs-string">"ggrid"</span>)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, <span class="hljs-string">"red"</span>)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill-opacity"</span>, <span class="hljs-number">0.2</span>)
              .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, <span class="hljs-string">"red"</span>);
          }
        }

        <span class="hljs-title function_">addQtree</span>(grids, data);
      }
      <span class="hljs-keyword">if</span> (grids.<span class="hljs-property">type</span> == <span class="hljs-string">"geogrid"</span>) {
        <span class="hljs-title function_">addGeoGrid</span>(data, grids);
      }
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">addGeoGrid</span>(<span class="hljs-params">data, grids</span>) {
      <span class="hljs-keyword">let</span> points = data.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span>
        turf.<span class="hljs-title function_">point</span>(d.<span class="hljs-property">coordinates</span>, { <span class="hljs-attr">count</span>: d.<span class="hljs-property">properties</span>.<span class="hljs-property">number</span> })
      );
      <span class="hljs-keyword">let</span> mPoints = turf.<span class="hljs-title function_">featureCollection</span>(points);
      <span class="hljs-keyword">let</span> vPoints = turf.<span class="hljs-title function_">voronoi</span>(mPoints, {
        <span class="hljs-attr">bbox</span>: turf.<span class="hljs-title function_">bboxPolygon</span>(turf.<span class="hljs-title function_">bbox</span>(mPoints)).<span class="hljs-property">bbox</span>
      });
      <span class="hljs-keyword">let</span> bbox = turf.<span class="hljs-title function_">bboxPolygon</span>(turf.<span class="hljs-title function_">bbox</span>(mPoints)).<span class="hljs-property">bbox</span>;
      <span class="hljs-keyword">let</span> sPoints = turf.<span class="hljs-title function_">squareGrid</span>(
        [+bbox[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, +bbox[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>, +bbox[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>, +bbox[<span class="hljs-number">3</span>] + <span class="hljs-number">1</span>],
        grids.<span class="hljs-property">size</span>,
        {
          <span class="hljs-attr">units</span>: <span class="hljs-string">"degrees"</span>
        }
      );

      <span class="hljs-keyword">let</span> col = turf.<span class="hljs-title function_">collect</span>(sPoints, mPoints, <span class="hljs-string">"count"</span>, <span class="hljs-string">"count"</span>);

      <span class="hljs-keyword">let</span> colorScale = d3.<span class="hljs-title function_">scaleSqrt</span>().<span class="hljs-title function_">domain</span>([<span class="hljs-number">1</span>, <span class="hljs-number">83</span>]).<span class="hljs-title function_">range</span>([<span class="hljs-string">"yellow"</span>, <span class="hljs-string">"red"</span>]);
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Layer</span>({
        <span class="hljs-attr">geometry</span>: col.<span class="hljs-property">features</span>,
        <span class="hljs-attr">group</span>: glayer,
        <span class="hljs-attr">path</span>: path,
        <span class="hljs-attr">style</span>: {
          <span class="hljs-attr">stroke</span>: <span class="hljs-string">"none"</span>,
          <span class="hljs-string">"stroke-dasharray"</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-string">"stroke-dashoffset"</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-string">"stroke-linecap"</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-string">"stroke-linejoin"</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-string">"stroke-miterlimit"</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-string">"stroke-opacity"</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-string">"stroke-width"</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-attr">fill</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">feature</span>) {
            <span class="hljs-keyword">if</span> (feature.<span class="hljs-property">properties</span>.<span class="hljs-property">count</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">if</span> (feature.<span class="hljs-property">properties</span>.<span class="hljs-property">count</span>) {
                <span class="hljs-keyword">let</span> c = feature.<span class="hljs-property">properties</span>.<span class="hljs-property">count</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) {
                  <span class="hljs-keyword">return</span> a + b;
                });
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c, <span class="hljs-title function_">colorScale</span>(c));
                <span class="hljs-keyword">return</span> <span class="hljs-title function_">colorScale</span>(c);
              }
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-string">"none"</span>;
            }
          },
          <span class="hljs-string">"fill-opacity"</span>: <span class="hljs-number">1</span>,
          <span class="hljs-attr">opacity</span>: <span class="hljs-literal">null</span>
        }
      }).<span class="hljs-property">add</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">points</span>.<span class="hljs-property">show</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">points</span>.<span class="hljs-property">show</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">points</span>.<span class="hljs-property">data</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">let</span> groups = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">points</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> d.<span class="hljs-property">type</span>));
          <span class="hljs-title function_">createAnnotationGroups</span>(groups);
          <span class="hljs-title function_">addPoints</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span>.<span class="hljs-property">points</span>.<span class="hljs-property">data</span>);
        }
      }

      <span class="hljs-keyword">function</span> <span class="hljs-title function_">createAnnotationGroups</span>(<span class="hljs-params">groups</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> g <span class="hljs-keyword">of</span> groups) {
          gannotation.<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">"type-"</span> + uid + <span class="hljs-string">"-"</span> + g);
        }
      }

      <span class="hljs-keyword">function</span> <span class="hljs-title function_">addPoints</span>(<span class="hljs-params">data</span>) {
        <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>].<span class="hljs-property">name</span> !== <span class="hljs-string">""</span>) {
          <span class="hljs-keyword">var</span> z = <span class="hljs-string">""</span>;
          <span class="hljs-keyword">var</span> labelClass = <span class="hljs-string">"v-text-contextual-city"</span>;
          <span class="hljs-keyword">var</span> anchorPoint = <span class="hljs-string">"start"</span>;
          <span class="hljs-keyword">let</span> unit = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">var</span> dx = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">var</span> dy = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">for</span> (z <span class="hljs-keyword">in</span> data) {
            <span class="hljs-keyword">if</span> (data[z].<span class="hljs-property">x</span> &amp;&amp; data[z].<span class="hljs-property">y</span>) {
              data[z].<span class="hljs-property">lng</span> = data[z].<span class="hljs-property">x</span>;
              data[z].<span class="hljs-property">lat</span> = data[z].<span class="hljs-property">y</span>;
            }
            <span class="hljs-keyword">if</span> (data[z].<span class="hljs-property">latlng</span>) {
              data[z].<span class="hljs-property">lng</span> = data[z].<span class="hljs-property">latlng</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">","</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">trim</span>();
              data[z].<span class="hljs-property">lat</span> = data[z].<span class="hljs-property">latlng</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">","</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">trim</span>();
            }

            <span class="hljs-keyword">if</span> (data[z].<span class="hljs-property">name</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
              unit = <span class="hljs-number">4</span>;
              <span class="hljs-keyword">let</span> symbol = <span class="hljs-string">""</span>;
              <span class="hljs-keyword">let</span> shape = data[z].<span class="hljs-property">shape</span> ? data[z].<span class="hljs-property">shape</span> : <span class="hljs-string">"circle"</span>;
              <span class="hljs-keyword">let</span> adjustLabel = data[z].<span class="hljs-property">dir</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">"-"</span>) &gt; -<span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
              <span class="hljs-keyword">let</span> dir = data[z].<span class="hljs-property">dir</span>.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">"-"</span>)[<span class="hljs-number">0</span>];
              <span class="hljs-keyword">let</span> type = data[z].<span class="hljs-property">type</span>.<span class="hljs-title function_">trim</span>();

              <span class="hljs-keyword">if</span> ([<span class="hljs-string">"city1"</span>, <span class="hljs-string">"capital"</span>, <span class="hljs-string">"Admin-0 capital"</span>].<span class="hljs-title function_">indexOf</span>(type) &gt; -<span class="hljs-number">1</span>) {
                labelClass = <span class="hljs-string">"v-text-capital-city"</span>;
                symbol = <span class="hljs-string">"#iconStar"</span>;
              }
              <span class="hljs-keyword">if</span> ([<span class="hljs-string">"city2"</span>, <span class="hljs-string">"focal"</span>, <span class="hljs-string">"Admin-1 capital"</span>].<span class="hljs-title function_">indexOf</span>(type) &gt; -<span class="hljs-number">1</span>) {
                labelClass = <span class="hljs-string">"v-text-focal-city"</span>;
                symbol = <span class="hljs-string">"#iconCity"</span>;
              }
              <span class="hljs-keyword">if</span> ([<span class="hljs-string">"city3"</span>, <span class="hljs-string">"context"</span>, <span class="hljs-string">"Populated place"</span>].<span class="hljs-title function_">indexOf</span>(type) &gt; -<span class="hljs-number">1</span>) {
                labelClass = <span class="hljs-string">"v-text-contextual-city"</span>;
                symbol = <span class="hljs-string">"#iconCity"</span>;
              }
              <span class="hljs-keyword">if</span> ([<span class="hljs-string">"custom"</span>].<span class="hljs-title function_">indexOf</span>(type) &gt; -<span class="hljs-number">1</span>) {
                shape = data[z].<span class="hljs-property">shape</span> ? data[z].<span class="hljs-property">shape</span> : <span class="hljs-string">"circle"</span>;
                labelClass = data[z].<span class="hljs-property">group</span>;
              } <span class="hljs-keyword">else</span> {
                labelClass = <span class="hljs-string">"v-text-contextual-city"</span>;
              }

              <span class="hljs-keyword">if</span> (adjustLabel) {
                unit = data[z].<span class="hljs-property">dir</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">"-"</span>)[<span class="hljs-number">1</span>];
              }
              <span class="hljs-keyword">if</span> ([<span class="hljs-string">"N"</span>].<span class="hljs-title function_">indexOf</span>(dir) &gt; -<span class="hljs-number">1</span>) {
                anchorPoint = <span class="hljs-string">"middle"</span>;
                dx = <span class="hljs-number">0</span>;
                dy = -unit * <span class="hljs-number">2</span>;
              }
              <span class="hljs-keyword">if</span> ([<span class="hljs-string">"C"</span>].<span class="hljs-title function_">indexOf</span>(dir) &gt; -<span class="hljs-number">1</span>) {
                anchorPoint = <span class="hljs-string">"middle"</span>;
                dx = <span class="hljs-number">0</span>;
                dy = <span class="hljs-number">0</span>;
              }
              <span class="hljs-keyword">if</span> ([<span class="hljs-string">"NE"</span>].<span class="hljs-title function_">indexOf</span>(dir) &gt; -<span class="hljs-number">1</span>) {
                anchorPoint = <span class="hljs-string">"start"</span>;
                dx = unit + <span class="hljs-number">5</span>;
                dy = -unit;
              }
              <span class="hljs-keyword">if</span> ([<span class="hljs-string">"E"</span>].<span class="hljs-title function_">indexOf</span>(dir) &gt; -<span class="hljs-number">1</span>) {
                anchorPoint = <span class="hljs-string">"start"</span>;
                dx = unit + <span class="hljs-number">5</span>;
                dy = <span class="hljs-number">4</span>;
              }
              <span class="hljs-keyword">if</span> ([<span class="hljs-string">"SE"</span>].<span class="hljs-title function_">indexOf</span>(dir) &gt; -<span class="hljs-number">1</span>) {
                anchorPoint = <span class="hljs-string">"start"</span>;
                dx = unit + <span class="hljs-number">5</span>;
                dy = unit * <span class="hljs-number">3</span>;
              }
              <span class="hljs-keyword">if</span> ([<span class="hljs-string">"S"</span>].<span class="hljs-title function_">indexOf</span>(dir) &gt; -<span class="hljs-number">1</span>) {
                anchorPoint = <span class="hljs-string">"middle"</span>;
                dx = <span class="hljs-number">0</span>;
                dy = unit * <span class="hljs-number">3</span> + <span class="hljs-number">3</span>;
              }
              <span class="hljs-keyword">if</span> ([<span class="hljs-string">"SW"</span>].<span class="hljs-title function_">indexOf</span>(dir) &gt; -<span class="hljs-number">1</span>) {
                anchorPoint = <span class="hljs-string">"end"</span>;
                dx = -unit - <span class="hljs-number">5</span>;
                dy = unit * <span class="hljs-number">3</span>;
              }
              <span class="hljs-keyword">if</span> ([<span class="hljs-string">"W"</span>].<span class="hljs-title function_">indexOf</span>(dir) &gt; -<span class="hljs-number">1</span>) {
                anchorPoint = <span class="hljs-string">"end"</span>;
                dx = -unit - <span class="hljs-number">5</span>;
                dy = <span class="hljs-number">4</span>;
              }
              <span class="hljs-keyword">if</span> ([<span class="hljs-string">"NW"</span>].<span class="hljs-title function_">indexOf</span>(dir) &gt; -<span class="hljs-number">1</span>) {
                anchorPoint = <span class="hljs-string">"end"</span>;
                dx = -unit - <span class="hljs-number">5</span>;
                dy = -unit;
              }

              <span class="hljs-keyword">let</span> groupText = gannotation.<span class="hljs-title function_">select</span>(<span class="hljs-string">"#type-"</span> + uid + <span class="hljs-string">"-"</span> + type);

              <span class="hljs-keyword">if</span> (symbol == <span class="hljs-string">""</span>) {
                <span class="hljs-keyword">if</span> (shape == <span class="hljs-string">"circle"</span>) {
                  groupText
                    .<span class="hljs-title function_">append</span>(<span class="hljs-string">"g"</span>)
                    .<span class="hljs-title function_">append</span>(<span class="hljs-string">"circle"</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"r"</span>, data[z].<span class="hljs-property">size</span> ? data[z].<span class="hljs-property">size</span> : <span class="hljs-number">5</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, data[z].<span class="hljs-property">color</span> ? data[z].<span class="hljs-property">color</span> : <span class="hljs-string">"#412c26"</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, data[z].<span class="hljs-property">stroke</span> ? data[z].<span class="hljs-property">stroke</span> : <span class="hljs-string">"none"</span>)
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"stroke-width"</span>,
                      data[z][<span class="hljs-string">"stroke-width"</span>] ? data[z][<span class="hljs-string">"stroke-width"</span>] : <span class="hljs-number">0</span>
                    )
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"opacity"</span>, data[z].<span class="hljs-property">opacity</span> ? data[z].<span class="hljs-property">opacity</span> : <span class="hljs-number">1</span>)
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"cx"</span>,
                      (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-title function_">projection</span>([data[z].<span class="hljs-property">lat</span>, data[z].<span class="hljs-property">lng</span>])[<span class="hljs-number">0</span>];
                      })()
                    )
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"cy"</span>,
                      (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-title function_">projection</span>([data[z].<span class="hljs-property">lat</span>, data[z].<span class="hljs-property">lng</span>])[<span class="hljs-number">1</span>];
                      })()
                    );
                }
                <span class="hljs-keyword">if</span> (shape == <span class="hljs-string">"square"</span>) {
                  <span class="hljs-keyword">let</span> customIcon = d3
                    .<span class="hljs-title function_">symbol</span>()
                    .<span class="hljs-title function_">type</span>(d3.<span class="hljs-property">symbolSquare</span>)
                    .<span class="hljs-title function_">size</span>(data[z].<span class="hljs-property">size</span> ? data[z].<span class="hljs-property">size</span> : <span class="hljs-number">5</span>)();
                  groupText
                    .<span class="hljs-title function_">append</span>(<span class="hljs-string">"path"</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"d"</span>, customIcon)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, data[z].<span class="hljs-property">color</span> ? data[z].<span class="hljs-property">color</span> : <span class="hljs-string">"#412c26"</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, data[z].<span class="hljs-property">stroke</span> ? data[z].<span class="hljs-property">stroke</span> : <span class="hljs-string">"none"</span>)
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"stroke-width"</span>,
                      data[z][<span class="hljs-string">"stroke-width"</span>] ? data[z][<span class="hljs-string">"stroke-width"</span>] : <span class="hljs-number">0</span>
                    )
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"opacity"</span>, data[z].<span class="hljs-property">opacity</span> ? data[z].<span class="hljs-property">opacity</span> : <span class="hljs-number">1</span>)
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"transform"</span>,
                      <span class="hljs-string">`translate(<span class="hljs-subst">${projection([data[z].lat, data[z].lng])[<span class="hljs-number">0</span>]}</span>,<span class="hljs-subst">${
                        projection([data[z].lat, data[z].lng])[<span class="hljs-number">1</span>]
                      }</span>)`</span>
                    );
                }
                <span class="hljs-keyword">if</span> (shape == <span class="hljs-string">"triangle"</span>) {
                  <span class="hljs-keyword">let</span> customIcon = d3
                    .<span class="hljs-title function_">symbol</span>()
                    .<span class="hljs-title function_">type</span>(d3.<span class="hljs-property">symbolTriangle</span>)
                    .<span class="hljs-title function_">size</span>(data[z].<span class="hljs-property">size</span> ? data[z].<span class="hljs-property">size</span> : <span class="hljs-number">5</span>)();
                  groupText
                    .<span class="hljs-title function_">append</span>(<span class="hljs-string">"path"</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"d"</span>, customIcon)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, data[z].<span class="hljs-property">color</span> ? data[z].<span class="hljs-property">color</span> : <span class="hljs-string">"#412c26"</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, data[z].<span class="hljs-property">stroke</span> ? data[z].<span class="hljs-property">stroke</span> : <span class="hljs-string">"none"</span>)
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"stroke-width"</span>,
                      data[z][<span class="hljs-string">"stroke-width"</span>] ? data[z][<span class="hljs-string">"stroke-width"</span>] : <span class="hljs-number">0</span>
                    )
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"opacity"</span>, data[z].<span class="hljs-property">opacity</span> ? data[z].<span class="hljs-property">opacity</span> : <span class="hljs-number">1</span>)
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"transform"</span>,
                      <span class="hljs-string">`translate(<span class="hljs-subst">${projection([data[z].lat, data[z].lng])[<span class="hljs-number">0</span>]}</span>,<span class="hljs-subst">${
                        projection([data[z].lat, data[z].lng])[<span class="hljs-number">1</span>]
                      }</span>)`</span>
                    )
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"dx"</span>, data[z].<span class="hljs-property">dx</span> ? data[z].<span class="hljs-property">dx</span> : <span class="hljs-number">0</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"dy"</span>, data[z].<span class="hljs-property">dy</span> ? data[z].<span class="hljs-property">dy</span> : <span class="hljs-number">0</span>);
                }
                <span class="hljs-keyword">if</span> (shape == <span class="hljs-string">"cross"</span>) {
                  <span class="hljs-keyword">let</span> customIcon = d3
                    .<span class="hljs-title function_">symbol</span>()
                    .<span class="hljs-title function_">type</span>(d3.<span class="hljs-property">symbolCross</span>)
                    .<span class="hljs-title function_">size</span>(data[z].<span class="hljs-property">size</span> ? data[z].<span class="hljs-property">size</span> : <span class="hljs-number">5</span>)();
                  groupText
                    .<span class="hljs-title function_">append</span>(<span class="hljs-string">"path"</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"d"</span>, customIcon)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, data[z].<span class="hljs-property">color</span> ? data[z].<span class="hljs-property">color</span> : <span class="hljs-string">"#412c26"</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, data[z].<span class="hljs-property">stroke</span> ? data[z].<span class="hljs-property">stroke</span> : <span class="hljs-string">"none"</span>)
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"stroke-width"</span>,
                      data[z][<span class="hljs-string">"stroke-width"</span>] ? data[z][<span class="hljs-string">"stroke-width"</span>] : <span class="hljs-number">0</span>
                    )
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"opacity"</span>, data[z].<span class="hljs-property">opacity</span> ? data[z].<span class="hljs-property">opacity</span> : <span class="hljs-number">1</span>)
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"transform"</span>,
                      <span class="hljs-string">`translate(<span class="hljs-subst">${projection([data[z].lat, data[z].lng])[<span class="hljs-number">0</span>]}</span>,<span class="hljs-subst">${
                        projection([data[z].lat, data[z].lng])[<span class="hljs-number">1</span>]
                      }</span>)`</span>
                    )
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"dx"</span>, data[z].<span class="hljs-property">dx</span> ? data[z].<span class="hljs-property">dx</span> : <span class="hljs-number">0</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"dy"</span>, data[z].<span class="hljs-property">dy</span> ? data[z].<span class="hljs-property">dy</span> : <span class="hljs-number">0</span>);
                }
                <span class="hljs-keyword">if</span> (shape == <span class="hljs-string">"diamond"</span>) {
                  <span class="hljs-keyword">let</span> customIcon = d3
                    .<span class="hljs-title function_">symbol</span>()
                    .<span class="hljs-title function_">type</span>(d3.<span class="hljs-property">symbolDiamond</span>)
                    .<span class="hljs-title function_">size</span>(data[z].<span class="hljs-property">size</span> ? data[z].<span class="hljs-property">size</span> : <span class="hljs-number">5</span>)();
                  groupText
                    .<span class="hljs-title function_">append</span>(<span class="hljs-string">"path"</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"d"</span>, customIcon)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, data[z].<span class="hljs-property">color</span> ? data[z].<span class="hljs-property">color</span> : <span class="hljs-string">"#412c26"</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, data[z].<span class="hljs-property">stroke</span> ? data[z].<span class="hljs-property">stroke</span> : <span class="hljs-string">"none"</span>)
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"stroke-width"</span>,
                      data[z][<span class="hljs-string">"stroke-width"</span>] ? data[z][<span class="hljs-string">"stroke-width"</span>] : <span class="hljs-number">0</span>
                    )
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"opacity"</span>, data[z].<span class="hljs-property">opacity</span> ? data[z].<span class="hljs-property">opacity</span> : <span class="hljs-number">1</span>)
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"transform"</span>,
                      <span class="hljs-string">`translate(<span class="hljs-subst">${projection([data[z].lat, data[z].lng])[<span class="hljs-number">0</span>]}</span>,<span class="hljs-subst">${
                        projection([data[z].lat, data[z].lng])[<span class="hljs-number">1</span>]
                      }</span>)`</span>
                    )
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"dx"</span>, data[z].<span class="hljs-property">dx</span> ? data[z].<span class="hljs-property">dx</span> : <span class="hljs-number">0</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"dy"</span>, data[z].<span class="hljs-property">dy</span> ? data[z].<span class="hljs-property">dy</span> : <span class="hljs-number">0</span>);
                }
                <span class="hljs-keyword">if</span> (shape == <span class="hljs-string">"star"</span>) {
                  <span class="hljs-keyword">let</span> customIcon = d3
                    .<span class="hljs-title function_">symbol</span>()
                    .<span class="hljs-title function_">type</span>(d3.<span class="hljs-property">symbolStar</span>)
                    .<span class="hljs-title function_">size</span>(data[z].<span class="hljs-property">size</span> ? data[z].<span class="hljs-property">size</span> : <span class="hljs-number">5</span>)();
                  groupText
                    .<span class="hljs-title function_">append</span>(<span class="hljs-string">"path"</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"d"</span>, customIcon)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, data[z].<span class="hljs-property">color</span> ? data[z].<span class="hljs-property">color</span> : <span class="hljs-string">"#412c26"</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, data[z].<span class="hljs-property">stroke</span> ? data[z].<span class="hljs-property">stroke</span> : <span class="hljs-string">"none"</span>)
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"stroke-width"</span>,
                      data[z][<span class="hljs-string">"stroke-width"</span>] ? data[z][<span class="hljs-string">"stroke-width"</span>] : <span class="hljs-number">0</span>
                    )
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"opacity"</span>, data[z].<span class="hljs-property">opacity</span> ? data[z].<span class="hljs-property">opacity</span> : <span class="hljs-number">1</span>)
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"transform"</span>,
                      <span class="hljs-string">`translate(<span class="hljs-subst">${projection([data[z].lat, data[z].lng])[<span class="hljs-number">0</span>]}</span>,<span class="hljs-subst">${
                        projection([data[z].lat, data[z].lng])[<span class="hljs-number">1</span>]
                      }</span>)`</span>
                    )
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"dx"</span>, data[z].<span class="hljs-property">dx</span> ? data[z].<span class="hljs-property">dx</span> : <span class="hljs-number">0</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"dy"</span>, data[z].<span class="hljs-property">dy</span> ? data[z].<span class="hljs-property">dy</span> : <span class="hljs-number">0</span>);
                }
                <span class="hljs-keyword">if</span> (shape == <span class="hljs-string">"wye"</span>) {
                  <span class="hljs-keyword">let</span> customIcon = d3
                    .<span class="hljs-title function_">symbol</span>()
                    .<span class="hljs-title function_">type</span>(d3.<span class="hljs-property">symbolWye</span>)
                    .<span class="hljs-title function_">size</span>(data[z].<span class="hljs-property">size</span> ? data[z].<span class="hljs-property">size</span> : <span class="hljs-number">5</span>)();
                  groupText
                    .<span class="hljs-title function_">append</span>(<span class="hljs-string">"path"</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"d"</span>, customIcon)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"fill"</span>, data[z].<span class="hljs-property">color</span> ? data[z].<span class="hljs-property">color</span> : <span class="hljs-string">"#412c26"</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"stroke"</span>, data[z].<span class="hljs-property">stroke</span> ? data[z].<span class="hljs-property">stroke</span> : <span class="hljs-string">"none"</span>)
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"stroke-width"</span>,
                      data[z][<span class="hljs-string">"stroke-width"</span>] ? data[z][<span class="hljs-string">"stroke-width"</span>] : <span class="hljs-number">0</span>
                    )
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"opacity"</span>, data[z].<span class="hljs-property">opacity</span> ? data[z].<span class="hljs-property">opacity</span> : <span class="hljs-number">1</span>)
                    .<span class="hljs-title function_">attr</span>(
                      <span class="hljs-string">"transform"</span>,
                      <span class="hljs-string">`translate(<span class="hljs-subst">${projection([data[z].lat, data[z].lng])[<span class="hljs-number">0</span>]}</span>,<span class="hljs-subst">${
                        projection([data[z].lat, data[z].lng])[<span class="hljs-number">1</span>]
                      }</span>)`</span>
                    )
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"dx"</span>, data[z].<span class="hljs-property">dx</span> ? data[z].<span class="hljs-property">dx</span> : <span class="hljs-number">0</span>)
                    .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"dy"</span>, data[z].<span class="hljs-property">dy</span> ? data[z].<span class="hljs-property">dy</span> : <span class="hljs-number">0</span>);
                }
              } <span class="hljs-keyword">else</span> {
                groupText
                  .<span class="hljs-title function_">append</span>(<span class="hljs-string">"use"</span>)
                  .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"href"</span>, symbol)
                  .<span class="hljs-title function_">attr</span>(
                    <span class="hljs-string">"transform"</span>,
                    <span class="hljs-string">`translate(<span class="hljs-subst">${projection([data[z].lat, data[z].lng])[<span class="hljs-number">0</span>]}</span>,<span class="hljs-subst">${
                      projection([data[z].lat, data[z].lng])[<span class="hljs-number">1</span>]
                    }</span>)`</span>
                  )
                  .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"dx"</span>, data[z].<span class="hljs-property">dx</span> ? data[z].<span class="hljs-property">dx</span> : <span class="hljs-number">0</span>)
                  .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"dy"</span>, data[z].<span class="hljs-property">dy</span> ? data[z].<span class="hljs-property">dy</span> : <span class="hljs-number">0</span>);
              }

              <span class="hljs-keyword">if</span> ([<span class="hljs-string">"C"</span>].<span class="hljs-title function_">indexOf</span>(dir) &gt; -<span class="hljs-number">1</span>) {
                groupText
                  .<span class="hljs-title function_">append</span>(<span class="hljs-string">"text"</span>)
                  .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">`<span class="hljs-subst">${data[z].name}</span>`</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">" "</span>, <span class="hljs-string">"_"</span>)) <span class="hljs-comment">//should be replace all</span>
                  .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"class"</span>, labelClass)
                  .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"text-anchor"</span>, anchorPoint)
                  .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"alignment-baseline"</span>, <span class="hljs-string">"middle"</span>)
                  .<span class="hljs-title function_">text</span>(data[z].<span class="hljs-property">name</span>)
                  .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"transform"</span>, <span class="hljs-string">`translate(<span class="hljs-subst">${dx}</span>, <span class="hljs-subst">${dy}</span>)`</span>)
                  .<span class="hljs-title function_">attr</span>(
                    <span class="hljs-string">"x"</span>,
                    (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
                      <span class="hljs-keyword">return</span> <span class="hljs-title function_">projection</span>([data[z].<span class="hljs-property">lat</span>, data[z].<span class="hljs-property">lng</span>])[<span class="hljs-number">0</span>];
                    })()
                  )
                  .<span class="hljs-title function_">attr</span>(
                    <span class="hljs-string">"y"</span>,
                    (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
                      <span class="hljs-keyword">return</span> <span class="hljs-title function_">projection</span>([data[z].<span class="hljs-property">lat</span>, data[z].<span class="hljs-property">lng</span>])[<span class="hljs-number">1</span>];
                    })()
                  );
              } <span class="hljs-keyword">else</span> {
                groupText
                  .<span class="hljs-title function_">append</span>(<span class="hljs-string">"text"</span>)
                  .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"id"</span>, <span class="hljs-string">`<span class="hljs-subst">${data[z].name}</span>`</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">" "</span>, <span class="hljs-string">"_"</span>)) <span class="hljs-comment">//should be replace all</span>
                  .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"class"</span>, labelClass)
                  .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"text-anchor"</span>, anchorPoint)
                  .<span class="hljs-title function_">text</span>(data[z].<span class="hljs-property">name</span>)
                  .<span class="hljs-title function_">attr</span>(<span class="hljs-string">"transform"</span>, <span class="hljs-string">`translate(<span class="hljs-subst">${dx}</span>, <span class="hljs-subst">${dy}</span>)`</span>)
                  .<span class="hljs-title function_">attr</span>(
                    <span class="hljs-string">"x"</span>,
                    (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
                      <span class="hljs-keyword">return</span> <span class="hljs-title function_">projection</span>([data[z].<span class="hljs-property">lat</span>, data[z].<span class="hljs-property">lng</span>])[<span class="hljs-number">0</span>];
                    })()
                  )
                  .<span class="hljs-title function_">attr</span>(
                    <span class="hljs-string">"y"</span>,
                    (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
                      <span class="hljs-keyword">return</span> <span class="hljs-title function_">projection</span>([data[z].<span class="hljs-property">lat</span>, data[z].<span class="hljs-property">lng</span>])[<span class="hljs-number">1</span>];
                    })()
                  );
              }
            }
          }
        } <span class="hljs-keyword">else</span> {
        }
      }
    }

    <span class="hljs-keyword">return</span> graphic.<span class="hljs-title function_">node</span>();
  }
}
</code></pre>
<div class="observablehq observablehq--block"><!--:d071e268:--></div>
<div class="observablehq observablehq--block"><!--:20759fbd:--></div>
<div class="observablehq observablehq--block"><!--:2d6cb8cd:--></div>
<div class="observablehq observablehq--block"><!--:513f582c:--></div>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:353fc809:--></div>
<div class="observablehq observablehq--block"><!--:869287f4:--></div>
<div class="observablehq observablehq--block"><!--:fbf42667:--></div>
<div class="observablehq observablehq--block"><!--:26b37714:--></div>
<div class="observablehq observablehq--block"><!--:c524bdaf:--></div>
<div class="observablehq observablehq--block"><!--:48e9abf1:--></div>
<div class="observablehq observablehq--block"><!--:25266b90:--></div>
<div class="observablehq observablehq--block"><!--:404f59f1:--></div>
<div class="observablehq observablehq--block"><!--:4c994a9a:--></div>
<div class="observablehq observablehq--block"><!--:7069867e:--></div>
<div class="observablehq observablehq--block"><!--:a6f39d2a:--></div>
<div class="observablehq observablehq--block"><!--:eeb2f35d:--></div>
<div class="observablehq observablehq--block"><!--:3bb28735:--></div>
<div class="observablehq observablehq--block"><!--:4ed27055:--></div>
</main>
<footer id="observablehq-footer">
<div>Built with <a href="https://observablehq.com/" target="_blank" rel="noopener noreferrer">Observable</a> on <a title="2025-01-22T06:32:34">Jan 22, 2025</a>.</div>
</footer>
</div>
