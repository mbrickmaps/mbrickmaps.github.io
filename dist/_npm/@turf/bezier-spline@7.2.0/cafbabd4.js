/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.37.0.
 * Original file: /npm/@turf/bezier-spline@7.2.0/dist/esm/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{lineString as s}from"../helpers@7.2.0/28807c9c.js";import{getGeom as t}from"../invariant@7.2.0/671cab78.js";var i=class{constructor(s){this.points=s.points||[],this.duration=s.duration||1e4,this.sharpness=s.sharpness||.85,this.centers=[],this.controls=[],this.stepLength=s.stepLength||60,this.length=this.points.length,this.delay=0;for(let s=0;s<this.length;s++)this.points[s].z=this.points[s].z||0;for(let s=0;s<this.length-1;s++){const t=this.points[s],i=this.points[s+1];this.centers.push({x:(t.x+i.x)/2,y:(t.y+i.y)/2,z:(t.z+i.z)/2})}this.controls.push([this.points[0],this.points[0]]);for(let s=0;s<this.centers.length-1;s++){const t=this.points[s+1].x-(this.centers[s].x+this.centers[s+1].x)/2,i=this.points[s+1].y-(this.centers[s].y+this.centers[s+1].y)/2,h=this.points[s+1].z-(this.centers[s].y+this.centers[s+1].z)/2;this.controls.push([{x:(1-this.sharpness)*this.points[s+1].x+this.sharpness*(this.centers[s].x+t),y:(1-this.sharpness)*this.points[s+1].y+this.sharpness*(this.centers[s].y+i),z:(1-this.sharpness)*this.points[s+1].z+this.sharpness*(this.centers[s].z+h)},{x:(1-this.sharpness)*this.points[s+1].x+this.sharpness*(this.centers[s+1].x+t),y:(1-this.sharpness)*this.points[s+1].y+this.sharpness*(this.centers[s+1].y+i),z:(1-this.sharpness)*this.points[s+1].z+this.sharpness*(this.centers[s+1].z+h)}])}return this.controls.push([this.points[this.length-1],this.points[this.length-1]]),this.steps=this.cacheSteps(this.stepLength),this}cacheSteps(s){const t=[];let i=this.pos(0);t.push(0);for(let h=0;h<this.duration;h+=10){const n=this.pos(h);Math.sqrt((n.x-i.x)*(n.x-i.x)+(n.y-i.y)*(n.y-i.y)+(n.z-i.z)*(n.z-i.z))>s&&(t.push(h),i=n)}return t}vector(s){const t=this.pos(s+10),i=this.pos(s-10);return{angle:180*Math.atan2(t.y-i.y,t.x-i.x)/3.14,speed:Math.sqrt((i.x-t.x)*(i.x-t.x)+(i.y-t.y)*(i.y-t.y)+(i.z-t.z)*(i.z-t.z))}}pos(s){let t=s-this.delay;t<0&&(t=0),t>this.duration&&(t=this.duration-1);const i=t/this.duration;if(i>=1)return this.points[this.length-1];const h=Math.floor((this.points.length-1)*i);return function(s,t,i,h,n){const e=function(s){const t=s*s,i=t*s;return[i,3*t*(1-s),3*s*(1-s)*(1-s),(1-s)*(1-s)*(1-s)]}(s);return{x:n.x*e[0]+h.x*e[1]+i.x*e[2]+t.x*e[3],y:n.y*e[0]+h.y*e[1]+i.y*e[2]+t.y*e[3],z:n.z*e[0]+h.z*e[1]+i.z*e[2]+t.z*e[3]}}((this.length-1)*i-h,this.points[h],this.controls[h][1],this.controls[h+1][0],this.points[h+1])}};function h(h,n={}){const e=n.resolution||1e4,r=n.sharpness||.85,o=[],p=t(h).coordinates.map((s=>({x:s[0],y:s[1]}))),a=new i({duration:e,points:p,sharpness:r}),c=s=>{var t=a.pos(s);Math.floor(s/100)%2==0&&o.push([t.x,t.y])};for(var u=0;u<a.duration;u+=10)c(u);return c(a.duration),s(o,n.properties)}var n=h;export{h as bezierSpline,n as default};
