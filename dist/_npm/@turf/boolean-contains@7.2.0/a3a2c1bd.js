/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.37.0.
 * Original file: /npm/@turf/boolean-contains@7.2.0/dist/esm/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{bbox as r}from"../bbox@7.2.0/8d64fe90.js";import{booleanPointInPolygon as t}from"../boolean-point-in-polygon@7.2.0/080fdfef.js";import{booleanPointOnLine as o}from"../boolean-point-on-line@7.2.0/cd67869a.js";import{getGeom as e}from"../invariant@7.2.0/671cab78.js";function n(r,n){const l=e(r),m=e(n),y=l.type,P=m.type,w=l.coordinates,h=m.coordinates;switch(y){case"Point":if("Point"===P)return g(w,h);throw new Error("feature2 "+P+" geometry not supported");case"MultiPoint":switch(P){case"Point":return u(l,m);case"MultiPoint":return c(l,m);default:throw new Error("feature2 "+P+" geometry not supported")}case"LineString":switch(P){case"Point":return o(m,l,{ignoreEndVertices:!0});case"LineString":return a(l,m);case"MultiPoint":return s(l,m);default:throw new Error("feature2 "+P+" geometry not supported")}case"Polygon":switch(P){case"Point":return t(m,l,{ignoreBoundary:!0});case"LineString":return d(l,m);case"Polygon":return p(l,m);case"MultiPoint":return f(l,m);default:throw new Error("feature2 "+P+" geometry not supported")}case"MultiPolygon":if("Polygon"===P)return i(l,m);throw new Error("feature2 "+P+" geometry not supported");default:throw new Error("feature1 "+y+" geometry not supported")}}function i(r,t){return r.coordinates.some((r=>p({type:"Polygon",coordinates:r},t)))}function u(r,t){let o,e=!1;for(o=0;o<r.coordinates.length;o++)if(g(r.coordinates[o],t.coordinates)){e=!0;break}return e}function c(r,t){for(const o of t.coordinates){let t=!1;for(const e of r.coordinates)if(g(o,e)){t=!0;break}if(!t)return!1}return!0}function s(r,t){let e=!1;for(const n of t.coordinates)if(o(n,r,{ignoreEndVertices:!0})&&(e=!0),!o(n,r))return!1;return!!e}function f(r,o){for(const e of o.coordinates)if(!t(e,r,{ignoreBoundary:!0}))return!1;return!0}function a(r,t){let e=!1;for(const n of t.coordinates)if(o({type:"Point",coordinates:n},r,{ignoreEndVertices:!0})&&(e=!0),!o({type:"Point",coordinates:n},r,{ignoreEndVertices:!1}))return!1;return e}function d(o,e){let n=!1,i=0;if(!l(r(o),r(e)))return!1;for(;i<e.coordinates.length-1;i++){const r=m(e.coordinates[i],e.coordinates[i+1]);if(t({type:"Point",coordinates:r},o,{ignoreBoundary:!0})){n=!0;break}}return n}function p(o,n){if("Feature"===o.type&&null===o.geometry)return!1;if("Feature"===n.type&&null===n.geometry)return!1;if(!l(r(o),r(n)))return!1;const i=e(n).coordinates;for(const r of i)for(const e of r)if(!t(e,o))return!1;return!0}function l(r,t){return!(r[0]>t[0])&&(!(r[2]<t[2])&&(!(r[1]>t[1])&&!(r[3]<t[3])))}function g(r,t){return r[0]===t[0]&&r[1]===t[1]}function m(r,t){return[(r[0]+t[0])/2,(r[1]+t[1])/2]}var y=n;export{n as booleanContains,g as compareCoords,y as default,l as doBBoxOverlap,m as getMidpoint,d as isLineInPoly,a as isLineOnLine,c as isMultiPointInMultiPoint,f as isMultiPointInPoly,s as isMultiPointOnLine,u as isPointInMultiPoint,p as isPolyInPoly,i as isPolygonInMultiPolygon};
